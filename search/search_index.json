{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BunnyFarm","text":"<p>Like a well-organized farm where messages hop efficiently from producers to consumers, BunnyFarm provides a lightweight Ruby gem for managing background jobs using RabbitMQ. Each message becomes a living entity with its own behavior, routing intelligently through the message broker to the right workers.</p>"},{"location":"#what-is-bunnyfarm","title":"What is BunnyFarm?","text":"<p>The bunny farm is an abstraction in which the messages are encapsulated as classes. Instances of these BunnyFarm::Messages are hopping around the RabbitMQ as JSON strings with routing keys in the form of <code>MessageClassName.action</code> where action is a method on the MessageClassName instance.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\udc30 Message-Centric Design - Classes encapsulate behavior and data</li> <li>\ud83d\udd00 Smart Routing - Automatic routing with ClassName.action keys</li> <li>\ud83d\udce8 JSON Serialization - Simple, readable message format</li> <li>\u2699\ufe0f Flexible Configuration - Environment, YAML, or programmatic setup</li> <li>\ud83d\udd04 Workflow Support - Multi-step processes with message chaining</li> <li>\u23f0 Task Scheduling - Delayed execution with retry logic</li> <li>\ud83d\udee1\ufe0f Error Handling - Built-in success/failure tracking</li> <li>\ud83c\udfaf Simplicity First - K.I.S.S. design philosophy</li> </ul>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<p>BunnyFarm provides a clean, layered architecture that separates concerns and enables scalable message processing:</p> <p></p> <p>The architecture consists of four main layers:</p> <ol> <li>Ruby Application Layer - Your web apps, API servers, schedulers, and worker processes</li> <li>BunnyFarm Library Layer - Core components including Message classes, Publisher, Consumer, Config, and Router</li> <li>RabbitMQ Message Broker - Handles message routing, queuing, and delivery with exchanges and queues</li> <li>Persistence &amp; External Services - Databases, email services, file storage, APIs, and caching layers</li> </ol>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Get up and running with BunnyFarm in minutes:</p>"},{"location":"#installation","title":"Installation","text":"<p>Add this line to your application's Gemfile:</p> <pre><code>gem 'bunny_farm'\n</code></pre> <p>And then execute:</p> <pre><code>bundle install\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>require 'bunny_farm'\nrequire 'my_message_class'\n\n# Configure BunnyFarm\nBunnyFarm.config\n\n# Start processing messages (blocks)\nBunnyFarm.manage\n</code></pre>"},{"location":"#publishing-messages","title":"Publishing Messages","text":"<pre><code>require 'bunny_farm'\n\nBunnyFarm.config do\n  app_id 'my_job_name'\nend\n\n# Create and publish a message\nmessage = MyMessageClass.new\nmessage[:field1] = 'Hello'\nmessage[:field2] = 'World'\nmessage.publish('action') # routing key: MyMessageClass.action\n\nputs 'Success!' if message.successful?\n</code></pre>"},{"location":"#why-bunnyfarm","title":"Why BunnyFarm?","text":"<ul> <li>Simplistic? Because extensive is sometimes overkill</li> <li>JSON? Because binary compression is sometimes overkill  </li> <li>Bunny? Who doesn't like bunnies? They're like cats with long ears</li> <li>AMQP? I like AMQP. I like RabbitMQ as an AMQP broker</li> </ul> <p>BTW, at the farm bunnies grow best if planted ears up. \ud83d\udc30</p>"},{"location":"#whats-next","title":"What's Next?","text":"<ul> <li>Installation Guide - Detailed installation and setup</li> <li>Quick Start - Get running in 5 minutes</li> <li>Basic Concepts - Understand the fundamentals</li> <li>Examples - Comprehensive, runnable examples</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"api/configuration/","title":"Configuration API","text":"<p>Programmatic configuration interface.</p> <pre><code>BunnyFarm.config do\n  # Configuration options\nend\n</code></pre>"},{"location":"api/consumer/","title":"Consumer API","text":"<p>API for consuming and processing messages.</p>"},{"location":"api/consumer/#starting-consumer","title":"Starting Consumer","text":"<pre><code>BunnyFarm.manage\n</code></pre>"},{"location":"api/message-class/","title":"Message Class API Reference","text":"<p>The <code>BunnyFarm::Message</code> class is the foundation of the BunnyFarm library. All your message classes inherit from this base class to gain message processing capabilities.</p>"},{"location":"api/message-class/#class-definition","title":"Class Definition","text":"<pre><code>class YourMessage &lt; BunnyFarm::Message\n  fields :field1, :field2, { nested: [:field3, :field4] }\n  actions :action1, :action2\n\n  def action1\n    # Your processing logic\n  end\nend\n</code></pre>"},{"location":"api/message-class/#class-methods","title":"Class Methods","text":""},{"location":"api/message-class/#fieldsfield_definitions","title":"<code>fields(*field_definitions)</code>","text":"<p>Defines the expected data structure for the message.</p> <p>Parameters: - <code>field_definitions</code> - Variable number of field definitions</p> <p>Field Definition Types:</p> <pre><code># Simple fields\nfields :name, :email, :age\n\n# Nested objects  \nfields { customer: [:name, :email, :phone] }\n\n# Mixed definitions\nfields :order_id, :total, \n       { customer: [:name, :email] },\n       { items: [:product_id, :quantity, :price] }\n</code></pre> <p>Example: <pre><code>class OrderMessage &lt; BunnyFarm::Message\n  fields :order_id, :total,\n         { customer: [:name, :email, :phone] },\n         { billing_address: [:street, :city, :state, :zip] },\n         { items: [:product_id, :quantity, :price] }\nend\n</code></pre></p>"},{"location":"api/message-class/#actionsaction_names","title":"<code>actions(*action_names)</code>","text":"<p>Defines the available actions (operations) for this message type.</p> <p>Parameters: - <code>action_names</code> - Variable number of action symbols</p> <p>Example: <pre><code>class OrderMessage &lt; BunnyFarm::Message\n  actions :validate, :process_payment, :fulfill, :ship, :cancel\n\n  def validate\n    # Validation logic\n  end\n\n  def process_payment\n    # Payment logic  \n  end\nend\n</code></pre></p> <p>Routing Keys: Each action creates a routing key in the format: <code>MessageClassName.action</code> - <code>OrderMessage.validate</code> - <code>OrderMessage.process_payment</code> - <code>OrderMessage.fulfill</code></p>"},{"location":"api/message-class/#instance-methods","title":"Instance Methods","text":""},{"location":"api/message-class/#data-access","title":"Data Access","text":""},{"location":"api/message-class/#key","title":"<code>[](key)</code>","text":"<p>Get a field value using hash-like syntax.</p> <p>Parameters: - <code>key</code> - Field name as symbol or string</p> <p>Returns: - Field value or <code>nil</code> if not set</p> <p>Example: <pre><code>message = OrderMessage.new\nvalue = message[:customer_name]\nnested = message[:customer][:email]\n</code></pre></p>"},{"location":"api/message-class/#key-value","title":"<code>[]=(key, value)</code>","text":"<p>Set a field value using hash-like syntax.</p> <p>Parameters: - <code>key</code> - Field name as symbol or string - <code>value</code> - Value to set</p> <p>Example: <pre><code>message[:customer_name] = \"John Doe\"\nmessage[:customer] = { name: \"John\", email: \"john@example.com\" }\n</code></pre></p>"},{"location":"api/message-class/#keys","title":"<code>keys</code>","text":"<p>Get all available field keys.</p> <p>Returns: - Array of field keys</p> <p>Example: <pre><code>message.keys # =&gt; [:order_id, :customer, :items]\n</code></pre></p>"},{"location":"api/message-class/#state-management","title":"State Management","text":""},{"location":"api/message-class/#success","title":"<code>success!</code>","text":"<p>Mark the current operation as successful.</p> <p>Example: <pre><code>def process_order\n  # ... processing logic\n  success!\nend\n</code></pre></p>"},{"location":"api/message-class/#failureerror_message","title":"<code>failure(error_message)</code>","text":"<p>Mark the current operation as failed with an error message.</p> <p>Parameters: - <code>error_message</code> - String describing the failure</p> <p>Example: <pre><code>def process_payment  \n  if payment_declined?\n    failure(\"Payment was declined by bank\")\n  end\nend\n</code></pre></p>"},{"location":"api/message-class/#successful","title":"<code>successful?</code>","text":"<p>Check if the current operation was successful.</p> <p>Returns: - <code>true</code> if successful, <code>false</code> otherwise</p> <p>Example: <pre><code>def process_order\n  validate_order\n  return unless successful?\n\n  process_payment\n  return unless successful?\n\n  ship_order\nend\n</code></pre></p>"},{"location":"api/message-class/#failed","title":"<code>failed?</code>","text":"<p>Check if the current operation failed.</p> <p>Returns: - <code>true</code> if failed, <code>false</code> otherwise  </p> <p>Example: <pre><code>if message.failed?\n  puts \"Processing failed: #{message.errors.join(', ')}\"\nend\n</code></pre></p>"},{"location":"api/message-class/#errors","title":"<code>errors</code>","text":"<p>Get array of error messages accumulated during processing.</p> <p>Returns: - Array of error message strings</p> <p>Example: <pre><code>def validate\n  failure(\"Name is required\") if @items[:name].blank?\n  failure(\"Email is invalid\") unless valid_email?(@items[:email])\nend\n\n# Later...\nif message.failed?\n  message.errors # =&gt; [\"Name is required\", \"Email is invalid\"]\nend\n</code></pre></p>"},{"location":"api/message-class/#message-operations","title":"Message Operations","text":""},{"location":"api/message-class/#publishaction","title":"<code>publish(action)</code>","text":"<p>Publish the message with the specified action.</p> <p>Parameters: - <code>action</code> - Action name as string or symbol</p> <p>Returns: - <code>true</code> if published successfully, <code>false</code> otherwise</p> <p>Example: <pre><code>message = OrderMessage.new\nmessage[:order_id] = 12345\nmessage[:customer] = { name: \"John\", email: \"john@example.com\" }\n\nif message.publish('process')\n  puts \"Message published successfully\"\nelse  \n  puts \"Failed to publish: #{message.errors.join(', ')}\"\nend\n</code></pre></p> <p>Routing Key: The message will be routed using: <code>MessageClassName.action</code></p>"},{"location":"api/message-class/#to_json","title":"<code>to_json</code>","text":"<p>Convert the message data to JSON string.</p> <p>Returns: - JSON string representation of the message data</p> <p>Example: <pre><code>message[:name] = \"John\"\nmessage[:email] = \"john@example.com\"\njson = message.to_json\n# =&gt; '{\"name\":\"John\",\"email\":\"john@example.com\"}'\n</code></pre></p>"},{"location":"api/message-class/#instance-variables","title":"Instance Variables","text":""},{"location":"api/message-class/#items","title":"<code>@items</code>","text":"<p>Hash containing the validated and structured message data based on field definitions.</p> <p>Access: - Direct: <code>@items[:field_name]</code> - Hash-like: <code>message[:field_name]</code></p>"},{"location":"api/message-class/#elements","title":"<code>@elements</code>","text":"<p>Hash containing the raw message data as received from the message broker.</p>"},{"location":"api/message-class/#payload","title":"<code>@payload</code>","text":"<p>String containing the original JSON payload as received from RabbitMQ.</p>"},{"location":"api/message-class/#errors_1","title":"<code>@errors</code>","text":"<p>Array containing error messages accumulated during processing.</p>"},{"location":"api/message-class/#action-method-implementation","title":"Action Method Implementation","text":"<p>When you define actions, you must implement corresponding methods:</p> <pre><code>class OrderMessage &lt; BunnyFarm::Message\n  actions :validate, :process, :ship\n\n  def validate\n    # Validation logic here\n    validate_customer_info\n    validate_order_items\n    validate_shipping_address\n\n    # Mark as successful if no errors\n    success! if errors.empty?\n\n    # Return true for ACK, false for NACK\n    successful?\n  end\n\n  def process\n    # Processing logic\n    charge_payment\n    update_inventory\n\n    if payment_successful? &amp;&amp; inventory_updated?\n      success!\n    else\n      failure(\"Order processing failed\")\n    end\n\n    successful?\n  end\n\n  def ship\n    # Shipping logic\n    create_shipping_label\n    notify_carrier\n    send_tracking_info\n\n    success!\n    successful?\n  end\n\n  private\n\n  def validate_customer_info\n    failure(\"Customer name required\") if @items[:customer][:name].blank?\n    failure(\"Customer email required\") if @items[:customer][:email].blank?\n  end\n\n  def charge_payment\n    # Payment processing logic\n  end\nend\n</code></pre>"},{"location":"api/message-class/#error-handling-patterns","title":"Error Handling Patterns","text":""},{"location":"api/message-class/#basic-error-handling","title":"Basic Error Handling","text":"<pre><code>def risky_operation\n  begin\n    perform_external_call\n    success!\n  rescue ExternalServiceError =&gt; e\n    failure(\"External service failed: #{e.message}\")\n  rescue StandardError =&gt; e\n    failure(\"Unexpected error: #{e.message}\")\n  end\n\n  successful?\nend\n</code></pre>"},{"location":"api/message-class/#validation-with-multiple-errors","title":"Validation with Multiple Errors","text":"<pre><code>def validate\n  failure(\"Name required\") if @items[:name].blank?\n  failure(\"Email required\") if @items[:email].blank?\n  failure(\"Invalid email format\") unless valid_email?\n\n  success! if errors.empty?\n  successful?\nend\n</code></pre>"},{"location":"api/message-class/#conditional-processing","title":"Conditional Processing","text":"<pre><code>def process_order\n  validate_order\n  return unless successful?\n\n  authorize_payment  \n  return unless successful?\n\n  fulfill_order\n  return unless successful?\n\n  send_confirmation\nend\n</code></pre>"},{"location":"api/message-class/#best-practices","title":"Best Practices","text":""},{"location":"api/message-class/#1-always-return-success-status","title":"1. Always Return Success Status","text":"<p>Action methods should always return the result of <code>successful?</code>:</p> <pre><code>def my_action\n  # ... processing logic\n  success! # or failure(...)\n  successful? # Always return this\nend\n</code></pre>"},{"location":"api/message-class/#2-use-descriptive-error-messages","title":"2. Use Descriptive Error Messages","text":"<p>Provide clear, actionable error messages:</p> <pre><code># Good\nfailure(\"Customer email format is invalid: #{email}\")\n\n# Avoid  \nfailure(\"Invalid input\")\n</code></pre>"},{"location":"api/message-class/#3-implement-idempotent-operations","title":"3. Implement Idempotent Operations","text":"<p>Make operations safe to retry:</p> <pre><code>def charge_payment\n  return success! if already_charged?\n\n  # Perform charge only if not already done\n  result = payment_gateway.charge(@items[:amount])\n\n  if result.success?\n    success!\n  else\n    failure(\"Payment failed: #{result.error}\")\n  end\n\n  successful?\nend\n</code></pre>"},{"location":"api/message-class/#4-keep-actions-focused","title":"4. Keep Actions Focused","text":"<p>Each action should have a single, clear responsibility:</p> <pre><code># Good: Focused actions\nactions :validate_order, :process_payment, :ship_order\n\n# Avoid: Overly broad actions\nactions :handle_order # Too generic\n</code></pre>"},{"location":"api/publisher/","title":"Publisher API","text":"<p>API for publishing messages to RabbitMQ.</p>"},{"location":"api/publisher/#publishing-messages","title":"Publishing Messages","text":"<pre><code>message = OrderMessage.new\nmessage.publish('process')\n</code></pre>"},{"location":"architecture/integration/","title":"Integration Patterns","text":"<p>Common integration scenarios and patterns.</p>"},{"location":"architecture/integration/#event-driven-architecture","title":"Event-Driven Architecture","text":"<ul> <li>Service communication</li> <li>Event sourcing</li> <li>CQRS patterns</li> </ul>"},{"location":"architecture/message-flow/","title":"Message Flow","text":"<p>Detailed message processing flow through the system.</p>"},{"location":"architecture/message-flow/#flow-stages","title":"Flow Stages","text":"<ol> <li>Creation</li> <li>Publishing</li> <li>Routing</li> <li>Consumption</li> <li>Processing</li> <li>Acknowledgment</li> </ol>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>BunnyFarm provides a clean, layered architecture that separates concerns and enables scalable message processing. This section covers the overall system design and how components interact.</p> <p></p>"},{"location":"architecture/overview/#architectural-layers","title":"Architectural Layers","text":""},{"location":"architecture/overview/#1-ruby-application-layer","title":"1. Ruby Application Layer","text":"<p>The top layer consists of your Ruby applications that produce and consume messages:</p> <p>Producers: - Web applications handling user requests - API servers processing external requests - Scheduled jobs and cron tasks - Other microservices</p> <p>Consumers: - Background worker processes - Microservices handling specific domains - Event processors - Data pipeline components</p>"},{"location":"architecture/overview/#2-bunnyfarm-library-layer","title":"2. BunnyFarm Library Layer","text":"<p>The BunnyFarm library provides the core abstractions and functionality:</p> <p>Core Components:</p>"},{"location":"architecture/overview/#message-classes","title":"Message Classes","text":"<ul> <li>Base class for all message types</li> <li>DSL for defining data structure (fields)</li> <li>DSL for defining operations (actions)</li> <li>Built-in serialization and validation</li> </ul>"},{"location":"architecture/overview/#publisher","title":"Publisher","text":"<ul> <li>Message publishing functionality</li> <li>Connection management</li> <li>Routing key generation</li> <li>Error handling</li> </ul>"},{"location":"architecture/overview/#consumer","title":"Consumer","text":"<ul> <li>Message consumption and processing</li> <li>Automatic deserialization</li> <li>Action method routing</li> <li>ACK/NACK management</li> </ul>"},{"location":"architecture/overview/#configuration","title":"Configuration","text":"<ul> <li>Environment-based configuration</li> <li>YAML configuration file support</li> <li>Programmatic configuration</li> <li>Connection parameter management</li> </ul>"},{"location":"architecture/overview/#router","title":"Router","text":"<ul> <li>Routing key parsing and generation</li> <li>Action method dispatching</li> <li>Message type resolution</li> </ul>"},{"location":"architecture/overview/#3-rabbitmq-message-broker","title":"3. RabbitMQ Message Broker","text":"<p>RabbitMQ serves as the message broker layer:</p> <p>Key Components:</p>"},{"location":"architecture/overview/#exchange","title":"Exchange","text":"<ul> <li>Routes messages based on routing keys</li> <li>Typically uses topic exchange for flexible routing</li> <li>Handles message durability and persistence</li> </ul>"},{"location":"architecture/overview/#queues","title":"Queues","text":"<ul> <li>Store messages until consumed</li> <li>Support various configurations (durable, auto-delete, etc.)</li> <li>Handle message ordering and priority</li> </ul>"},{"location":"architecture/overview/#management-interface","title":"Management Interface","text":"<ul> <li>Web-based administration</li> <li>Queue and exchange monitoring</li> <li>Performance metrics and alerts</li> </ul>"},{"location":"architecture/overview/#4-persistence-external-services","title":"4. Persistence &amp; External Services","text":"<p>The bottom layer includes external dependencies:</p> <ul> <li>Databases - For persistent data storage</li> <li>Email Services - For notification sending</li> <li>File Storage - For document and media handling</li> <li>External APIs - For third-party integrations</li> <li>Caching - Redis/Memcached for performance</li> </ul>"},{"location":"architecture/overview/#message-flow-architecture","title":"Message Flow Architecture","text":"<p>The message processing follows a predictable flow:</p>"},{"location":"architecture/overview/#1-message-creation","title":"1. Message Creation","text":"<pre><code>message = OrderMessage.new\nmessage[:order_id] = 12345\nmessage[:customer] = customer_data\n</code></pre>"},{"location":"architecture/overview/#2-publishing","title":"2. Publishing","text":"<pre><code>message.publish('process') # Creates routing key: OrderMessage.process\n</code></pre>"},{"location":"architecture/overview/#3-rabbitmq-routing","title":"3. RabbitMQ Routing","text":"<ul> <li>Exchange receives message with routing key</li> <li>Routes to appropriate queue(s) based on bindings</li> <li>Message persisted until consumed</li> </ul>"},{"location":"architecture/overview/#4-consumption","title":"4. Consumption","text":"<pre><code>BunnyFarm.manage # Consumer polls for messages\n</code></pre>"},{"location":"architecture/overview/#5-processing","title":"5. Processing","text":"<ul> <li>Message deserialized from JSON</li> <li>Appropriate action method called</li> <li>Business logic executed</li> </ul>"},{"location":"architecture/overview/#6-acknowledgment","title":"6. Acknowledgment","text":"<ul> <li>Success returns <code>true</code> \u2192 ACK sent to RabbitMQ</li> <li>Failure returns <code>false</code> \u2192 NACK sent (message requeued or dead-lettered)</li> </ul>"},{"location":"architecture/overview/#design-principles","title":"Design Principles","text":""},{"location":"architecture/overview/#message-centric-design","title":"Message-Centric Design","text":"<p>Messages are first-class objects that encapsulate both data and behavior:</p> <pre><code>class OrderMessage &lt; BunnyFarm::Message\n  # Data structure\n  fields :order_id, :customer, :items\n\n  # Behavior  \n  actions :validate, :process, :ship\n\n  def validate\n    # Validation logic\n  end\nend\n</code></pre> <p>This approach provides: - Encapsulation - Data and behavior stay together - Discoverability - Easy to understand what a message can do - Testability - Individual message types can be unit tested</p>"},{"location":"architecture/overview/#predictable-routing","title":"Predictable Routing","text":"<p>Routing keys follow a consistent pattern:</p> <pre><code>MessageClassName.action\n</code></pre> <p>Examples: - <code>OrderMessage.process</code> - <code>EmailMessage.send</code> - <code>ReportMessage.generate</code></p> <p>Benefits: - Transparency - Easy to understand message flow - Debugging - Clear routing paths - Monitoring - Trackable message types</p>"},{"location":"architecture/overview/#json-serialization","title":"JSON Serialization","text":"<p>All message data uses JSON serialization:</p> <pre><code>{\n  \"order_id\": 12345,\n  \"customer\": {\n    \"name\": \"John Doe\", \n    \"email\": \"john@example.com\"\n  },\n  \"items\": [\n    {\"product_id\": 1, \"quantity\": 2}\n  ]\n}\n</code></pre> <p>Advantages: - Human readable - Easy debugging and monitoring - Language agnostic - Other systems can integrate - Tooling support - JSON tools widely available</p>"},{"location":"architecture/overview/#scalability-patterns","title":"Scalability Patterns","text":""},{"location":"architecture/overview/#horizontal-scaling","title":"Horizontal Scaling","text":"<p>Add more consumers to handle increased load:</p> <pre><code># Worker 1\nBunnyFarm.config { app_id 'worker_1' }\nBunnyFarm.manage\n\n# Worker 2  \nBunnyFarm.config { app_id 'worker_2' }\nBunnyFarm.manage\n\n# Worker N...\n</code></pre> <p>Multiple consumers can process messages from the same queue concurrently.</p>"},{"location":"architecture/overview/#queue-partitioning","title":"Queue Partitioning","text":"<p>Use different queues for different message types or priorities:</p> <pre><code># High priority queue\nBunnyFarm.config do\n  queue_name 'high_priority_orders'\n  routing_key 'OrderMessage.urgent'\nend\n\n# Normal priority queue\nBunnyFarm.config do  \n  queue_name 'normal_orders'\n  routing_key 'OrderMessage.process'\nend\n</code></pre>"},{"location":"architecture/overview/#load-balancing","title":"Load Balancing","text":"<p>RabbitMQ automatically load balances messages across multiple consumers using round-robin distribution.</p>"},{"location":"architecture/overview/#fault-tolerance","title":"Fault Tolerance","text":""},{"location":"architecture/overview/#message-persistence","title":"Message Persistence","text":"<p>Messages can be persisted to disk:</p> <pre><code>BunnyFarm.config do\n  exchange_options durable: true\n  queue_options durable: true\n  message_options persistent: true\nend\n</code></pre>"},{"location":"architecture/overview/#error-handling","title":"Error Handling","text":"<p>Failed messages can be: - Retried - Requeued automatically - Dead lettered - Sent to error queue - Logged - For manual inspection</p> <pre><code>def risky_operation\n  begin\n    perform_work\n    success!\n  rescue =&gt; e\n    failure(\"Operation failed: #{e.message}\")\n  end\n\n  successful?\nend\n</code></pre>"},{"location":"architecture/overview/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"<p>Prevent cascading failures:</p> <pre><code>def external_service_call\n  if circuit_breaker.open?\n    failure(\"Circuit breaker open - service unavailable\")\n    return\n  end\n\n  begin\n    result = external_service.call\n    circuit_breaker.record_success\n    success!\n  rescue =&gt; e\n    circuit_breaker.record_failure\n    failure(\"External service failed: #{e.message}\")\n  end\n\n  successful?\nend\n</code></pre>"},{"location":"architecture/overview/#monitoring-and-observability","title":"Monitoring and Observability","text":""},{"location":"architecture/overview/#rabbitmq-management","title":"RabbitMQ Management","text":"<p>Built-in monitoring via RabbitMQ management interface: - Queue depths and rates - Consumer activity - Message flow metrics - Connection status</p>"},{"location":"architecture/overview/#application-metrics","title":"Application Metrics","text":"<p>Track application-level metrics:</p> <pre><code>def process_order\n  StatsD.increment 'orders.processing.started'\n\n  result = perform_processing\n\n  if successful?\n    StatsD.increment 'orders.processing.success'\n  else\n    StatsD.increment 'orders.processing.failed'\n  end\n\n  result\nend\n</code></pre>"},{"location":"architecture/overview/#logging","title":"Logging","text":"<p>Structured logging for message processing:</p> <pre><code>def process_order\n  logger.info \"Processing order\", order_id: @items[:order_id]\n\n  # ... processing\n\n  if successful?\n    logger.info \"Order processed successfully\", order_id: @items[:order_id]\n  else\n    logger.error \"Order processing failed\", \n                 order_id: @items[:order_id], \n                 errors: errors\n  end\nend\n</code></pre>"},{"location":"architecture/overview/#integration-patterns","title":"Integration Patterns","text":""},{"location":"architecture/overview/#event-driven-architecture","title":"Event-Driven Architecture","text":"<p>Use BunnyFarm for event-driven communication between services:</p> <pre><code># Service A publishes events\norder_created = OrderCreatedEvent.new\norder_created[:order_id] = order.id\norder_created.publish('notify_services')\n\n# Service B subscribes to events\nclass OrderCreatedEvent &lt; BunnyFarm::Message\n  actions :update_inventory, :send_confirmation\n\n  def update_inventory\n    # Update inventory service\n  end\n\n  def send_confirmation  \n    # Send customer confirmation\n  end\nend\n</code></pre>"},{"location":"architecture/overview/#saga-pattern","title":"Saga Pattern","text":"<p>Implement distributed transactions:</p> <pre><code>class OrderSaga &lt; BunnyFarm::Message\n  actions :start, :process_payment, :reserve_inventory, \n          :ship_order, :complete, :compensate\n\n  def start\n    # Begin saga\n    next_step('process_payment')\n  end\n\n  def process_payment\n    if payment_successful?\n      next_step('reserve_inventory')\n    else\n      compensate('payment_failed')\n    end\n  end\n\n  private\n\n  def next_step(action)\n    self.class.new(@items).publish(action)\n  end\nend\n</code></pre>"},{"location":"architecture/overview/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/overview/#connection-pooling","title":"Connection Pooling","text":"<p>For high-throughput scenarios:</p> <pre><code>BunnyFarm.config do\n  connection_pool_size 10\n  channel_pool_size 20\nend\n</code></pre>"},{"location":"architecture/overview/#batch-processing","title":"Batch Processing","text":"<p>Process multiple messages together:</p> <pre><code>def process_batch\n  messages = consume_batch(size: 100)\n\n  ActiveRecord::Base.transaction do\n    messages.each(&amp;:process)\n  end\nend\n</code></pre>"},{"location":"architecture/overview/#memory-management","title":"Memory Management","text":"<p>For long-running consumers:</p> <pre><code>def process_with_memory_management\n  GC.start if processed_count % 1000 == 0\n\n  # Process message\n\n  ensure\n    # Cleanup resources\nend\n</code></pre>"},{"location":"architecture/overview/#next-steps","title":"Next Steps","text":"<p>Explore specific architectural topics:</p> <ul> <li>Message Flow - Detailed message processing flow</li> <li>Scaling Patterns - Horizontal and vertical scaling strategies  </li> <li>Integration Patterns - Common integration scenarios</li> <li>Configuration - Architecture configuration options</li> </ul>"},{"location":"architecture/scaling/","title":"Scaling Patterns","text":"<p>Horizontal and vertical scaling strategies.</p>"},{"location":"architecture/scaling/#horizontal-scaling","title":"Horizontal Scaling","text":"<ul> <li>Multiple consumer instances</li> <li>Queue partitioning</li> <li>Load balancing</li> </ul>"},{"location":"configuration/environment-variables/","title":"Environment Variables","text":"<p>Complete reference for BunnyFarm environment variables.</p>"},{"location":"configuration/environment-variables/#connection-variables","title":"Connection Variables","text":"<ul> <li><code>AMQP_HOST</code> - RabbitMQ hostname</li> <li><code>AMQP_PORT</code> - Connection port</li> <li><code>AMQP_USER</code> - Username</li> <li><code>AMQP_PASS</code> - Password</li> </ul>"},{"location":"configuration/environment-variables/#message-routing","title":"Message Routing","text":"<ul> <li><code>AMQP_EXCHANGE</code> - Exchange name</li> <li><code>AMQP_QUEUE</code> - Queue name</li> <li><code>AMQP_ROUTING_KEY</code> - Routing key pattern</li> </ul>"},{"location":"configuration/overview/","title":"Configuration Overview","text":"<p>BunnyFarm provides flexible configuration options to suit different environments and deployment scenarios. This guide covers all available configuration methods and options.</p> <p></p>"},{"location":"configuration/overview/#configuration-methods","title":"Configuration Methods","text":"<p>BunnyFarm supports multiple configuration approaches that follow a clear priority hierarchy:</p> <ol> <li>Built-in defaults - Safe defaults for development</li> <li>YAML configuration files - Environment-specific settings</li> <li>Environment variables - Runtime configuration</li> <li>Programmatic configuration - Code-based overrides</li> </ol> <p>Later configurations override earlier ones, giving you maximum flexibility.</p>"},{"location":"configuration/overview/#environment-variables","title":"Environment Variables","text":"<p>The simplest way to configure BunnyFarm is through environment variables:</p> <pre><code># Connection settings\nexport AMQP_HOST=localhost\nexport AMQP_VHOST=/\nexport AMQP_PORT=5672\nexport AMQP_USER=guest\nexport AMQP_PASS=guest\n\n# Message routing\nexport AMQP_EXCHANGE=my_exchange\nexport AMQP_QUEUE=my_queue\nexport AMQP_ROUTING_KEY='#'\n\n# Application identity\nexport AMQP_APP_NAME=my_app\n</code></pre>"},{"location":"configuration/overview/#programmatic-configuration","title":"Programmatic Configuration","text":"<p>Configure BunnyFarm directly in your Ruby code:</p> <pre><code>BunnyFarm.config do\n  env 'production'\n  app_id 'order_processor'\n  bunny_file 'config/rabbitmq.yml.erb'\nend\n</code></pre>"},{"location":"configuration/overview/#available-options","title":"Available Options","text":""},{"location":"configuration/overview/#basic-configuration","title":"Basic Configuration","text":"<pre><code>BunnyFarm.config do\n  app_id 'my_application'        # Application identifier\n  env 'production'               # Environment name  \nend\n</code></pre>"},{"location":"configuration/overview/#file-based-configuration","title":"File-based Configuration","text":"<pre><code>BunnyFarm.config do\n  bunny_file 'config/custom.yml' # Custom config file path\nend\n</code></pre>"},{"location":"configuration/overview/#yaml-configuration","title":"YAML Configuration","text":"<p>Use YAML files for environment-specific configuration with ERB support:</p> <p>config/bunny.yml.erb: <pre><code>defaults: &amp;defaults\n  host: &lt;%= ENV['AMQP_HOST'] || 'localhost' %&gt;\n  vhost: &lt;%= ENV['AMQP_VHOST'] || '/' %&gt;\n  port: &lt;%= (ENV['AMQP_PORT'] || 5672).to_i %&gt;\n  user: &lt;%= ENV['AMQP_USER'] || 'guest' %&gt;\n  pass: &lt;%= ENV['AMQP_PASS'] || 'guest' %&gt;\n  exchange_name: &lt;%= ENV['AMQP_EXCHANGE'] || 'my_exchange' %&gt;\n  queue_name: &lt;%= ENV['AMQP_QUEUE'] || 'my_queue' %&gt;\n  routing_key: &lt;%= ENV['AMQP_ROUTING_KEY'] || '#' %&gt;\n  app_name: &lt;%= ENV['AMQP_APP_NAME'] || 'bunny_farm_job' %&gt;\n\ndevelopment:\n  &lt;&lt;: *defaults\n\ntest:\n  &lt;&lt;: *defaults\n  exchange_name: test_exchange\n  queue_name: test_queue\n\nproduction:\n  &lt;&lt;: *defaults\n  host: amqp.production.com\n  exchange_name: prod_exchange\n</code></pre></p>"},{"location":"configuration/overview/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"configuration/overview/#connection-parameters","title":"Connection Parameters","text":"Parameter Environment Variable Description Default <code>host</code> <code>AMQP_HOST</code> RabbitMQ server hostname <code>localhost</code> <code>vhost</code> <code>AMQP_VHOST</code> Virtual host <code>/</code> <code>port</code> <code>AMQP_PORT</code> Connection port <code>5672</code> <code>user</code> <code>AMQP_USER</code> Username <code>guest</code> <code>pass</code> <code>AMQP_PASS</code> Password <code>guest</code>"},{"location":"configuration/overview/#message-routing-parameters","title":"Message Routing Parameters","text":"Parameter Environment Variable Description Default <code>exchange_name</code> <code>AMQP_EXCHANGE</code> Exchange name <code>bunny_farm_exchange</code> <code>queue_name</code> <code>AMQP_QUEUE</code> Queue name <code>bunny_farm_queue</code> <code>routing_key</code> <code>AMQP_ROUTING_KEY</code> Routing key pattern <code>#</code>"},{"location":"configuration/overview/#application-parameters","title":"Application Parameters","text":"Parameter Environment Variable Description Default <code>app_name</code> <code>AMQP_APP_NAME</code> Application name <code>bunny_farm_app</code>"},{"location":"configuration/overview/#environment-specific-configuration","title":"Environment-Specific Configuration","text":""},{"location":"configuration/overview/#development-configuration","title":"Development Configuration","text":"<pre><code># config/environments/development.rb\nBunnyFarm.config do\n  env 'development'\n  # Uses local RabbitMQ with default settings\nend\n</code></pre>"},{"location":"configuration/overview/#production-configuration","title":"Production Configuration","text":"<pre><code># config/environments/production.rb  \nBunnyFarm.config do\n  env 'production'\n  bunny_file Rails.root.join('config', 'rabbitmq.yml.erb')\nend\n</code></pre>"},{"location":"configuration/overview/#test-configuration","title":"Test Configuration","text":"<pre><code># config/environments/test.rb\nBunnyFarm.config do\n  env 'test'\n  app_id 'test_suite'\nend\n</code></pre>"},{"location":"configuration/overview/#common-configuration-patterns","title":"Common Configuration Patterns","text":""},{"location":"configuration/overview/#docker-configuration","title":"Docker Configuration","text":"<pre><code># docker-compose.yml environment section\nenvironment:\n  - AMQP_HOST=rabbitmq\n  - AMQP_EXCHANGE=app_exchange\n  - AMQP_QUEUE=app_queue\n  - AMQP_USER=app_user\n  - AMQP_PASS=secret_password\n</code></pre>"},{"location":"configuration/overview/#kubernetes-configuration","title":"Kubernetes Configuration","text":"<pre><code># k8s-configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: bunny-farm-config\ndata:\n  AMQP_HOST: \"rabbitmq-service\"\n  AMQP_EXCHANGE: \"production_exchange\"\n  AMQP_QUEUE: \"production_queue\"\n</code></pre>"},{"location":"configuration/overview/#cloud-configuration","title":"Cloud Configuration","text":"<pre><code># For cloud RabbitMQ services\nBunnyFarm.config do\n  case ENV['RAILS_ENV']\n  when 'production'\n    # Use CloudAMQP URL\n    connection_string ENV['CLOUDAMQP_URL']\n  when 'staging'  \n    connection_string ENV['STAGING_AMQP_URL']\n  end\nend\n</code></pre>"},{"location":"configuration/overview/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"configuration/overview/#connection-options","title":"Connection Options","text":"<pre><code>BunnyFarm.config do\n  connection_options do\n    heartbeat 30\n    connection_timeout 10\n    read_timeout 30\n    write_timeout 30\n  end\nend\n</code></pre>"},{"location":"configuration/overview/#exchange-options","title":"Exchange Options","text":"<pre><code>BunnyFarm.config do\n  exchange_options do\n    durable true\n    auto_delete false\n    type :topic\n  end\nend\n</code></pre>"},{"location":"configuration/overview/#queue-options","title":"Queue Options","text":"<pre><code>BunnyFarm.config do\n  queue_options do\n    durable true\n    auto_delete false\n    exclusive false\n    arguments({\n      'x-message-ttl' =&gt; 60000,\n      'x-max-length' =&gt; 1000\n    })\n  end\nend\n</code></pre>"},{"location":"configuration/overview/#message-options","title":"Message Options","text":"<pre><code>BunnyFarm.config do\n  message_options do\n    persistent true\n    mandatory false\n    immediate false\n  end\nend\n</code></pre>"},{"location":"configuration/overview/#configuration-validation","title":"Configuration Validation","text":"<p>BunnyFarm validates configuration at startup:</p> <pre><code>begin\n  BunnyFarm.config do\n    host 'invalid-host'\n    port 'invalid-port'\n  end\nrescue BunnyFarm::ConfigurationError =&gt; e\n  puts \"Configuration error: #{e.message}\"\nend\n</code></pre>"},{"location":"configuration/overview/#best-practices","title":"Best Practices","text":""},{"location":"configuration/overview/#1-use-environment-variables-for-secrets","title":"1. Use Environment Variables for Secrets","text":"<pre><code># Good: Use environment variables for sensitive data\nBunnyFarm.config do\n  user ENV['RABBITMQ_USER']\n  pass ENV['RABBITMQ_PASSWORD']\nend\n\n# Avoid: Hard-coding secrets\nBunnyFarm.config do\n  user 'admin'\n  pass 'secret123' # Don't do this!\nend\n</code></pre>"},{"location":"configuration/overview/#2-environment-specific-configuration","title":"2. Environment-Specific Configuration","text":"<pre><code># config/application.rb\ncase Rails.env\nwhen 'development'\n  BunnyFarm.config { env 'development' }\nwhen 'test'\n  BunnyFarm.config { env 'test' }  \nwhen 'production'\n  BunnyFarm.config do\n    env 'production'\n    bunny_file 'config/production_rabbitmq.yml'\n  end\nend\n</code></pre>"},{"location":"configuration/overview/#3-connection-pooling-for-high-load","title":"3. Connection Pooling for High Load","text":"<pre><code>BunnyFarm.config do\n  connection_pool_size 10\n  channel_pool_size 50\nend\n</code></pre>"},{"location":"configuration/overview/#4-monitoring-configuration","title":"4. Monitoring Configuration","text":"<pre><code>BunnyFarm.config do\n  # Enable detailed logging\n  log_level :info\n\n  # Health check endpoint\n  health_check_enabled true\n  health_check_port 8080\nend\n</code></pre>"},{"location":"configuration/overview/#configuration-debugging","title":"Configuration Debugging","text":""},{"location":"configuration/overview/#check-current-configuration","title":"Check Current Configuration","text":"<pre><code># In Rails console or Ruby script\nputs BunnyFarm.current_config.inspect\n</code></pre>"},{"location":"configuration/overview/#test-connection","title":"Test Connection","text":"<pre><code># Verify connection works\nBunnyFarm.test_connection\n</code></pre>"},{"location":"configuration/overview/#configuration-validation_1","title":"Configuration Validation","text":"<pre><code># Validate configuration without connecting\nBunnyFarm.validate_config\n</code></pre>"},{"location":"configuration/overview/#troubleshooting","title":"Troubleshooting","text":""},{"location":"configuration/overview/#common-issues","title":"Common Issues","text":""},{"location":"configuration/overview/#connection-refused","title":"Connection Refused","text":"<pre><code>Error: Connection refused - connect(2)\n</code></pre> <p>Solutions: - Verify RabbitMQ is running: <code>systemctl status rabbitmq-server</code> - Check host and port configuration - Verify firewall settings</p>"},{"location":"configuration/overview/#authentication-failed","title":"Authentication Failed","text":"<pre><code>Error: ACCESS_REFUSED - Login was refused\n</code></pre> <p>Solutions: - Verify username and password - Check user permissions in RabbitMQ - Ensure virtual host exists and user has access</p>"},{"location":"configuration/overview/#exchangequeue-not-found","title":"Exchange/Queue Not Found","text":"<pre><code>Error: NOT_FOUND - no exchange 'my_exchange'\n</code></pre> <p>Solutions: - Create exchange and queue manually - Enable auto-creation in configuration - Check exchange/queue names for typos</p>"},{"location":"configuration/overview/#next-steps","title":"Next Steps","text":"<p>With configuration mastered, explore:</p> <ul> <li>Environment Variables - Complete environment variable reference</li> <li>YAML Configuration - Advanced YAML configuration patterns</li> <li>Programmatic Setup - Dynamic configuration scenarios</li> </ul>"},{"location":"configuration/programmatic-setup/","title":"Programmatic Setup","text":"<p>Configuring BunnyFarm through Ruby code.</p> <pre><code>BunnyFarm.config do\n  host 'amqp.example.com'\n  port 5672\nend\n</code></pre>"},{"location":"configuration/yaml-configuration/","title":"YAML Configuration","text":"<p>Using YAML files for structured configuration.</p>"},{"location":"configuration/yaml-configuration/#basic-structure","title":"Basic Structure","text":"<pre><code>development:\n  host: localhost\n  port: 5672\n  user: guest\n  pass: guest\n</code></pre>"},{"location":"core-features/configuration/","title":"Configuration","text":"<p>BunnyFarm provides flexible configuration options that adapt to different environments and deployment scenarios. This page covers configuration as a core feature that enables the framework's adaptability.</p>"},{"location":"core-features/configuration/#configuration-philosophy","title":"Configuration Philosophy","text":"<p>BunnyFarm follows the principle of sensible defaults with easy customization:</p> <ul> <li>Zero configuration - Works out of the box for development</li> <li>Environment aware - Adapts to different deployment contexts</li> <li>Override hierarchy - Multiple configuration layers with clear precedence</li> <li>Runtime flexibility - Can be configured programmatically or declaratively</li> </ul>"},{"location":"core-features/configuration/#configuration-as-a-feature","title":"Configuration as a Feature","text":""},{"location":"core-features/configuration/#environment-adaptation","title":"Environment Adaptation","text":"<p>BunnyFarm automatically adapts to different environments:</p> <pre><code># Development - uses localhost defaults\nBunnyFarm.config { env 'development' }\n\n# Production - uses environment variables or config files\nBunnyFarm.config do\n  env 'production'\n  bunny_file 'config/production.yml'\nend\n\n# Testing - isolated configuration\nBunnyFarm.config do\n  env 'test'\n  exchange_name 'test_exchange'\n  queue_name 'test_queue'\nend\n</code></pre>"},{"location":"core-features/configuration/#dynamic-configuration","title":"Dynamic Configuration","text":"<p>Configuration can adapt to runtime conditions:</p> <pre><code>BunnyFarm.config do\n  # Dynamic host selection\n  host case ENV['REGION']\n       when 'us-east' then 'amqp-us-east.example.com'\n       when 'eu-west' then 'amqp-eu-west.example.com'\n       else 'localhost'\n       end\n\n  # Scale queue count based on load\n  queue_name \"orders_#{ENV['INSTANCE_ID'] || 'default'}\"\n\n  # Conditional features\n  if ENV['ENABLE_MONITORING'] == 'true'\n    monitoring_enabled true\n    metrics_endpoint 'http://prometheus:9090'\n  end\nend\n</code></pre>"},{"location":"core-features/configuration/#configuration-methods","title":"Configuration Methods","text":""},{"location":"core-features/configuration/#1-environment-variables","title":"1. Environment Variables","text":"<p>The most common production configuration method:</p> <pre><code># Connection settings\nexport AMQP_HOST=amqp.example.com\nexport AMQP_PORT=5672\nexport AMQP_USER=app_user\nexport AMQP_PASS=secret_password\nexport AMQP_VHOST=production\n\n# Application settings\nexport AMQP_EXCHANGE=production_exchange\nexport AMQP_QUEUE=production_queue\nexport AMQP_ROUTING_KEY='#'\nexport AMQP_APP_NAME=order_processor\n</code></pre> <p>Usage: <pre><code># Automatically uses environment variables\nBunnyFarm.config\n</code></pre></p>"},{"location":"core-features/configuration/#2-yaml-configuration-files","title":"2. YAML Configuration Files","text":"<p>Structured configuration with ERB templating:</p> <p>config/bunny.yml.erb: <pre><code>defaults: &amp;defaults\n  host: &lt;%= ENV['AMQP_HOST'] || 'localhost' %&gt;\n  port: &lt;%= ENV['AMQP_PORT'] || 5672 %&gt;\n  user: &lt;%= ENV['AMQP_USER'] || 'guest' %&gt;\n  pass: &lt;%= ENV['AMQP_PASS'] || 'guest' %&gt;\n  vhost: &lt;%= ENV['AMQP_VHOST'] || '/' %&gt;\n\ndevelopment:\n  &lt;&lt;: *defaults\n  exchange_name: dev_exchange\n  queue_name: dev_queue\n\nstaging:\n  &lt;&lt;: *defaults\n  host: staging-amqp.example.com\n  exchange_name: staging_exchange\n\nproduction:\n  &lt;&lt;: *defaults\n  host: &lt;%= ENV.fetch('PRODUCTION_AMQP_HOST') %&gt;\n  exchange_name: production_exchange\n  connection_pool_size: 10\n</code></pre></p> <p>Usage: <pre><code>BunnyFarm.config do\n  env Rails.env\n  bunny_file 'config/bunny.yml.erb'\nend\n</code></pre></p>"},{"location":"core-features/configuration/#3-programmatic-configuration","title":"3. Programmatic Configuration","text":"<p>Ruby code-based configuration:</p> <pre><code>BunnyFarm.config do\n  # Basic settings\n  app_id 'order_processor'\n  env Rails.env\n\n  # Connection settings\n  host 'amqp.example.com'\n  port 5672\n  vhost '/orders'\n\n  # Queue configuration\n  exchange_name 'order_exchange'\n  queue_name 'order_processing'\n  routing_key 'OrderMessage.*'\n\n  # Advanced options\n  connection_pool_size 5\n  heartbeat_interval 30\n\n  # Message options\n  message_options do\n    persistent true\n    mandatory false\n  end\n\n  # Queue options\n  queue_options do\n    durable true\n    auto_delete false\n    arguments({\n      'x-message-ttl' =&gt; 300_000,  # 5 minutes\n      'x-max-length' =&gt; 10_000\n    })\n  end\nend\n</code></pre>"},{"location":"core-features/configuration/#configuration-patterns","title":"Configuration Patterns","text":""},{"location":"core-features/configuration/#multi-environment-setup","title":"Multi-Environment Setup","text":"<p>Rails Application: <pre><code># config/environments/development.rb\nBunnyFarm.config do\n  env 'development'\n  log_level :debug\nend\n\n# config/environments/staging.rb\nBunnyFarm.config do\n  env 'staging'\n  bunny_file Rails.root.join('config', 'rabbitmq.yml')\n  log_level :info\nend\n\n# config/environments/production.rb\nBunnyFarm.config do\n  env 'production'\n  bunny_file Rails.root.join('config', 'rabbitmq.yml')\n  log_level :warn\n\n  # Production-specific settings\n  connection_pool_size 10\n  heartbeat_interval 60\n  connection_timeout 30\nend\n</code></pre></p>"},{"location":"core-features/configuration/#docker-configuration","title":"Docker Configuration","text":"<p>docker-compose.yml: <pre><code>version: '3.8'\nservices:\n  app:\n    build: .\n    environment:\n      AMQP_HOST: rabbitmq\n      AMQP_USER: app\n      AMQP_PASS: ${RABBITMQ_PASSWORD}\n      AMQP_EXCHANGE: ${APP_EXCHANGE:-app_exchange}\n      AMQP_QUEUE: ${APP_QUEUE:-app_queue}\n      RAILS_ENV: production\n    depends_on:\n      - rabbitmq\n\n  rabbitmq:\n    image: rabbitmq:3-management\n    environment:\n      RABBITMQ_DEFAULT_USER: app\n      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD}\n</code></pre></p>"},{"location":"core-features/configuration/#kubernetes-configuration","title":"Kubernetes Configuration","text":"<p>ConfigMap: <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: bunny-farm-config\ndata:\n  AMQP_HOST: \"rabbitmq-service\"\n  AMQP_EXCHANGE: \"production_exchange\"\n  AMQP_QUEUE: \"production_queue\"\n  AMQP_APP_NAME: \"order-processor\"\n</code></pre></p> <p>Secret: <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: bunny-farm-secret\ntype: Opaque\ndata:\n  AMQP_USER: YXBwX3VzZXI=  # base64 encoded\n  AMQP_PASS: c2VjcmV0X3Bhc3M=  # base64 encoded\n</code></pre></p> <p>Deployment: <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: order-processor\nspec:\n  template:\n    spec:\n      containers:\n      - name: app\n        image: order-processor:latest\n        envFrom:\n        - configMapRef:\n            name: bunny-farm-config\n        - secretRef:\n            name: bunny-farm-secret\n</code></pre></p>"},{"location":"core-features/configuration/#advanced-configuration-features","title":"Advanced Configuration Features","text":""},{"location":"core-features/configuration/#configuration-validation","title":"Configuration Validation","text":"<pre><code>BunnyFarm.config do\n  # Validate required settings\n  required_env_vars = %w[AMQP_HOST AMQP_USER AMQP_PASS]\n  missing = required_env_vars.select { |var| ENV[var].nil? }\n\n  raise \"Missing required environment variables: #{missing.join(', ')}\" if missing.any?\n\n  # Set configuration\n  host ENV['AMQP_HOST']\n  user ENV['AMQP_USER']\n  pass ENV['AMQP_PASS']\nend\n</code></pre>"},{"location":"core-features/configuration/#conditional-configuration","title":"Conditional Configuration","text":"<pre><code>BunnyFarm.config do\n  # Base configuration\n  app_id 'message_processor'\n\n  # Environment-specific\n  case ENV['RAILS_ENV']\n  when 'development'\n    log_level :debug\n    queue_name 'dev_queue'\n  when 'test'\n    log_level :fatal\n    queue_name \"test_queue_#{ENV['TEST_ENV_NUMBER']}\"\n  when 'production'\n    log_level :info\n    connection_pool_size 20\n    queue_name 'prod_queue'\n\n    # Enable monitoring in production\n    monitoring_enabled true\n    health_check_port 8080\n  end\n\n  # Feature flags\n  if ENV['ENABLE_DEAD_LETTERS'] == 'true'\n    dead_letter_exchange 'failed_messages'\n    dead_letter_routing_key 'failed.#'\n  end\nend\n</code></pre>"},{"location":"core-features/configuration/#runtime-configuration-updates","title":"Runtime Configuration Updates","text":"<pre><code>class ConfigurableWorker\n  def initialize\n    @config_check_interval = 60  # Check every minute\n    @last_config_check = Time.current\n    setup_configuration\n  end\n\n  def process_messages\n    loop do\n      check_configuration_updates if should_check_config?\n\n      BunnyFarm.manage_single_message\n    end\n  end\n\n  private\n\n  def should_check_config?\n    Time.current - @last_config_check &gt; @config_check_interval\n  end\n\n  def check_configuration_updates\n    new_config = load_config_from_source\n\n    if config_changed?(new_config)\n      logger.info \"Configuration updated, reloading...\"\n      update_configuration(new_config)\n    end\n\n    @last_config_check = Time.current\n  end\n\n  def config_changed?(new_config)\n    @current_config_hash != new_config.hash\n  end\n\n  def update_configuration(new_config)\n    BunnyFarm.reconfigure(new_config)\n    @current_config_hash = new_config.hash\n  end\nend\n</code></pre>"},{"location":"core-features/configuration/#configuration-security","title":"Configuration Security","text":""},{"location":"core-features/configuration/#secret-management","title":"Secret Management","text":"<p>Never store secrets in code or version control:</p> <pre><code># Good: Use environment variables or secret management\nBunnyFarm.config do\n  user ENV['AMQP_USER']\n  pass ENV['AMQP_PASS']  # From Kubernetes secret, HashiCorp Vault, etc.\nend\n\n# Avoid: Hardcoded secrets\nBunnyFarm.config do\n  user 'admin'\n  pass 'secret123'  # Don't do this!\nend\n</code></pre>"},{"location":"core-features/configuration/#encrypted-configuration","title":"Encrypted Configuration","text":"<p>For sensitive configuration files:</p> <pre><code>require 'openssl'\n\nclass EncryptedConfig\n  def self.load(file_path, key)\n    encrypted_data = File.read(file_path)\n    cipher = OpenSSL::Cipher.new('AES-256-CBC')\n    cipher.decrypt\n    cipher.key = key\n\n    decrypted_data = cipher.update(encrypted_data) + cipher.final\n    YAML.safe_load(decrypted_data)\n  end\nend\n\n# Usage\nconfig_key = ENV['CONFIG_ENCRYPTION_KEY']\nconfig = EncryptedConfig.load('config/encrypted_bunny.yml', config_key)\n\nBunnyFarm.config do\n  host config['host']\n  user config['user']\n  pass config['pass']\nend\n</code></pre>"},{"location":"core-features/configuration/#monitoring-configuration","title":"Monitoring Configuration","text":""},{"location":"core-features/configuration/#health-checks","title":"Health Checks","text":"<pre><code>BunnyFarm.config do\n  # Enable health check endpoint\n  health_check_enabled true\n  health_check_port 8080\n  health_check_path '/health'\nend\n\n# Health check responds with:\n# GET /health\n# {\n#   \"status\": \"healthy\",\n#   \"rabbitmq_connection\": \"ok\",\n#   \"queue_depth\": 42,\n#   \"last_message_processed\": \"2024-01-15T10:30:00Z\"\n# }\n</code></pre>"},{"location":"core-features/configuration/#metrics-and-logging","title":"Metrics and Logging","text":"<pre><code>BunnyFarm.config do\n  # Detailed logging\n  log_level ENV['LOG_LEVEL']&amp;.downcase&amp;.to_sym || :info\n  log_format :json  # For structured logging\n\n  # Metrics\n  metrics_enabled true\n  metrics_port 9090\n  metrics_path '/metrics'\n\n  # Custom metric tags\n  metric_tags({\n    environment: ENV['RAILS_ENV'],\n    region: ENV['AWS_REGION'],\n    instance: ENV['HOSTNAME']\n  })\nend\n</code></pre>"},{"location":"core-features/configuration/#best-practices","title":"Best Practices","text":""},{"location":"core-features/configuration/#1-layer-configuration-appropriately","title":"1. Layer Configuration Appropriately","text":"<pre><code># Layer 1: Sensible defaults\nBunnyFarm.config do\n  host 'localhost'\n  port 5672\n  heartbeat_interval 30\nend\n\n# Layer 2: Environment-specific overrides\nBunnyFarm.config do\n  bunny_file \"config/#{Rails.env}.yml\"\nend\n\n# Layer 3: Runtime overrides\nBunnyFarm.config do\n  host ENV['AMQP_HOST'] if ENV['AMQP_HOST']\n  log_level ENV['LOG_LEVEL'].to_sym if ENV['LOG_LEVEL']\nend\n</code></pre>"},{"location":"core-features/configuration/#2-validate-critical-configuration","title":"2. Validate Critical Configuration","text":"<pre><code>BunnyFarm.config do\n  host ENV.fetch('AMQP_HOST')  # Will raise if missing\n\n  port_value = ENV['AMQP_PORT']&amp;.to_i || 5672\n  raise \"Invalid port: #{port_value}\" unless (1..65535).include?(port_value)\n  port port_value\nend\n</code></pre>"},{"location":"core-features/configuration/#3-document-configuration-options","title":"3. Document Configuration Options","text":"<pre><code># config/bunny_farm.rb\nBunnyFarm.config do\n  # Connection settings - required in production\n  host ENV['AMQP_HOST']        # RabbitMQ server hostname\n  port ENV['AMQP_PORT']&amp;.to_i  # RabbitMQ server port (default: 5672)\n  vhost ENV['AMQP_VHOST']      # Virtual host (default: '/')\n\n  # Authentication - use secrets in production\n  user ENV['AMQP_USER']        # Username (default: 'guest')\n  pass ENV['AMQP_PASS']        # Password (default: 'guest')\n\n  # Message routing\n  exchange_name ENV['AMQP_EXCHANGE'] || 'app_exchange'\n  queue_name ENV['AMQP_QUEUE'] || 'app_queue'\n  routing_key ENV['AMQP_ROUTING_KEY'] || '#'\nend\n</code></pre>"},{"location":"core-features/configuration/#next-steps","title":"Next Steps","text":"<p>Configuration mastery enables:</p> <ul> <li>Environment-specific deployment</li> <li>Performance tuning through configuration</li> <li>Security hardening with proper secret management</li> <li>Monitoring and observability through configuration</li> </ul>"},{"location":"core-features/error-handling/","title":"Error Handling","text":"<p>BunnyFarm provides comprehensive error handling mechanisms that help build resilient message processing systems with proper failure management and recovery strategies.</p> <p></p>"},{"location":"core-features/error-handling/#built-in-error-tracking","title":"Built-in Error Tracking","text":"<pre><code>class OrderMessage &lt; BunnyFarm::Message\n  def process\n    validate_order\n    return unless successful?\n\n    process_payment\n    return unless successful?\n\n    fulfill_order\n    return unless successful?\n\n    success!\n    successful?\n  end\n\n  private\n\n  def validate_order\n    failure(\"Order ID required\") unless @items[:order_id]\n    failure(\"Customer email required\") unless @items[:customer_email]\n\n    success! if errors.empty?\n  end\nend\n</code></pre>"},{"location":"core-features/error-handling/#error-recovery-patterns","title":"Error Recovery Patterns","text":""},{"location":"core-features/error-handling/#retry-with-exponential-backoff","title":"Retry with Exponential Backoff","text":"<pre><code>def process_with_retry\n  attempt = @items[:attempt] || 1\n\n  begin\n    risky_operation\n    success!\n  rescue RetryableError =&gt; e\n    if attempt &lt; 3\n      delay = 2 ** attempt\n      retry_message = self.class.new(@items)\n      retry_message[:attempt] = attempt + 1\n      retry_message.publish_delayed('process_with_retry', delay: delay)\n      success!  # Don't fail original message\n    else\n      failure(\"Failed after #{attempt} attempts: #{e.message}\")\n    end\n  end\n\n  successful?\nend\n</code></pre>"},{"location":"core-features/error-handling/#dead-letter-handling","title":"Dead Letter Handling","text":"<pre><code>class FailedMessage &lt; BunnyFarm::Message\n  actions :investigate, :retry, :archive\n\n  def investigate\n    puts \"Investigating failed message: #{@items[:original_error]}\"\n    success!\n  end\nend\n</code></pre>"},{"location":"core-features/error-handling/#best-practices","title":"Best Practices","text":"<ol> <li>Always handle exceptions gracefully</li> <li>Provide meaningful error messages</li> <li>Implement retry logic for transient failures</li> <li>Use dead letter queues for persistent failures</li> <li>Log errors for debugging and monitoring</li> </ol>"},{"location":"core-features/json-serialization/","title":"JSON Serialization","text":"<p>BunnyFarm uses JSON as its message serialization format, providing human-readable, language-agnostic message passing that's easy to debug and integrate with other systems.</p>"},{"location":"core-features/json-serialization/#why-json","title":"Why JSON?","text":""},{"location":"core-features/json-serialization/#human-readable","title":"Human Readable","text":"<p>JSON messages are easy to read and debug:</p> <pre><code>{\n  \"order_id\": 12345,\n  \"customer\": {\n    \"name\": \"John Doe\",\n    \"email\": \"john@example.com\"\n  },\n  \"items\": [\n    {\n      \"product_id\": 1,\n      \"quantity\": 2,\n      \"price\": 29.99\n    }\n  ],\n  \"total\": 59.98,\n  \"timestamp\": \"2024-01-15T10:30:00Z\"\n}\n</code></pre>"},{"location":"core-features/json-serialization/#language-agnostic","title":"Language Agnostic","text":"<p>Other systems can easily produce and consume messages:</p> <pre><code># Python producer\nimport json\nimport pika\n\nmessage = {\n    \"order_id\": 12345,\n    \"customer\": {\"name\": \"John\", \"email\": \"john@example.com\"},\n    \"total\": 59.98\n}\n\nchannel.basic_publish(\n    exchange='bunny_farm_exchange',\n    routing_key='OrderMessage.process',\n    body=json.dumps(message)\n)\n</code></pre>"},{"location":"core-features/json-serialization/#tooling-support","title":"Tooling Support","text":"<p>Rich ecosystem of JSON tools for debugging and monitoring.</p>"},{"location":"core-features/json-serialization/#serialization-process","title":"Serialization Process","text":""},{"location":"core-features/json-serialization/#publishing-flow","title":"Publishing Flow","text":"<pre><code>class OrderMessage &lt; BunnyFarm::Message\n  fields :order_id, :customer, :items\nend\n\n# 1. Create message\nmessage = OrderMessage.new\nmessage[:order_id] = 12345\nmessage[:customer] = { name: \"John\", email: \"john@example.com\" }\n\n# 2. Publish - automatic serialization\nmessage.publish('process')\n</code></pre> <p>Internal process: 1. Message data collected from <code>@items</code> hash 2. Data serialized to JSON string 3. JSON sent to RabbitMQ as message body 4. Routing key: <code>OrderMessage.process</code></p>"},{"location":"core-features/json-serialization/#consumption-flow","title":"Consumption Flow","text":"<pre><code># Consumer receives JSON message body and routing key\n# BunnyFarm automatically:\n# 1. Parses routing key \u2192 OrderMessage.process\n# 2. Deserializes JSON to Ruby hash\n# 3. Creates OrderMessage instance\n# 4. Populates @items with deserialized data\n# 5. Calls 'process' method\n\nclass OrderMessage &lt; BunnyFarm::Message\n  def process\n    puts @items[:order_id]        # 12345\n    puts @items[:customer][:name] # \"John\"\n    success!\n  end\nend\n</code></pre>"},{"location":"core-features/json-serialization/#data-types-and-serialization","title":"Data Types and Serialization","text":""},{"location":"core-features/json-serialization/#supported-data-types","title":"Supported Data Types","text":"<p>JSON supports these Ruby types natively:</p> <pre><code>message = OrderMessage.new\n\n# String\nmessage[:customer_name] = \"John Doe\"\n\n# Number (Integer/Float)\nmessage[:order_id] = 12345\nmessage[:total] = 59.99\n\n# Boolean\nmessage[:is_priority] = true\nmessage[:requires_signature] = false\n\n# Null\nmessage[:notes] = nil\n\n# Array\nmessage[:items] = [\n  { product_id: 1, quantity: 2 },\n  { product_id: 2, quantity: 1 }\n]\n\n# Hash/Object\nmessage[:customer] = {\n  name: \"John Doe\",\n  email: \"john@example.com\",\n  address: {\n    street: \"123 Main St\",\n    city: \"Boston\",\n    state: \"MA\"\n  }\n}\n</code></pre>"},{"location":"core-features/json-serialization/#serialized-json-output","title":"Serialized JSON Output","text":"<pre><code>{\n  \"customer_name\": \"John Doe\",\n  \"order_id\": 12345,\n  \"total\": 59.99,\n  \"is_priority\": true,\n  \"requires_signature\": false,\n  \"notes\": null,\n  \"items\": [\n    {\"product_id\": 1, \"quantity\": 2},\n    {\"product_id\": 2, \"quantity\": 1}\n  ],\n  \"customer\": {\n    \"name\": \"John Doe\", \n    \"email\": \"john@example.com\",\n    \"address\": {\n      \"street\": \"123 Main St\",\n      \"city\": \"Boston\",\n      \"state\": \"MA\"\n    }\n  }\n}\n</code></pre>"},{"location":"core-features/json-serialization/#complex-data-handling","title":"Complex Data Handling","text":""},{"location":"core-features/json-serialization/#date-and-time","title":"Date and Time","text":"<p>Dates should be serialized as ISO 8601 strings:</p> <pre><code>class OrderMessage &lt; BunnyFarm::Message\n  def set_timestamps\n    @items[:created_at] = Time.current.iso8601\n    @items[:processed_at] = DateTime.current.iso8601\n  end\n\n  def get_created_time\n    Time.parse(@items[:created_at])\n  end\nend\n\n# JSON output\n{\n  \"created_at\": \"2024-01-15T10:30:00Z\",\n  \"processed_at\": \"2024-01-15T10:30:00+00:00\"\n}\n</code></pre>"},{"location":"core-features/json-serialization/#binary-data","title":"Binary Data","text":"<p>Base64 encode binary data:</p> <pre><code>class DocumentMessage &lt; BunnyFarm::Message\n  def set_file_content(file_path)\n    content = File.binread(file_path)\n    @items[:file_content] = Base64.encode64(content)\n    @items[:filename] = File.basename(file_path)\n  end\n\n  def get_file_content\n    Base64.decode64(@items[:file_content])\n  end\nend\n</code></pre>"},{"location":"core-features/json-serialization/#custom-objects","title":"Custom Objects","text":"<p>Convert complex objects to simple data structures:</p> <pre><code>class Customer\n  attr_accessor :id, :name, :email, :created_at\n\n  def to_hash\n    {\n      id: @id,\n      name: @name,\n      email: @email,\n      created_at: @created_at.iso8601\n    }\n  end\n\n  def self.from_hash(data)\n    customer = new\n    customer.id = data[:id]\n    customer.name = data[:name]\n    customer.email = data[:email]\n    customer.created_at = Time.parse(data[:created_at])\n    customer\n  end\nend\n\nclass OrderMessage &lt; BunnyFarm::Message\n  def set_customer(customer)\n    @items[:customer] = customer.to_hash\n  end\n\n  def get_customer\n    Customer.from_hash(@items[:customer])\n  end\nend\n</code></pre>"},{"location":"core-features/json-serialization/#performance-considerations","title":"Performance Considerations","text":""},{"location":"core-features/json-serialization/#message-size","title":"Message Size","text":"<p>JSON can become large with complex data:</p> <pre><code># Monitor message sizes\nclass OrderMessage &lt; BunnyFarm::Message\n  def publish(action)\n    json_size = to_json.bytesize\n    logger.warn \"Large message: #{json_size} bytes\" if json_size &gt; 10.kilobytes\n\n    super(action)\n  end\nend\n</code></pre>"},{"location":"core-features/json-serialization/#compression","title":"Compression","text":"<p>For large messages, consider compression:</p> <pre><code>require 'zlib'\n\nclass LargeDataMessage &lt; BunnyFarm::Message\n  def set_compressed_data(data)\n    json_data = data.to_json\n    compressed = Zlib::Deflate.deflate(json_data)\n    @items[:compressed_data] = Base64.encode64(compressed)\n    @items[:compression] = 'zlib'\n  end\n\n  def get_decompressed_data\n    return @items[:data] unless @items[:compression]\n\n    compressed = Base64.decode64(@items[:compressed_data])\n    json_data = Zlib::Inflate.inflate(compressed)\n    JSON.parse(json_data)\n  end\nend\n</code></pre>"},{"location":"core-features/json-serialization/#parsing-performance","title":"Parsing Performance","text":"<p>JSON parsing can be optimized:</p> <pre><code># Use Oj gem for faster JSON parsing\nrequire 'oj'\n\nclass FastMessage &lt; BunnyFarm::Message\n  def to_json\n    Oj.dump(@items, mode: :compat)\n  end\n\n  def self.from_json(json_string)\n    data = Oj.load(json_string, mode: :compat)\n    message = new\n    message.instance_variable_set(:@items, data)\n    message\n  end\nend\n</code></pre>"},{"location":"core-features/json-serialization/#debugging-json-messages","title":"Debugging JSON Messages","text":""},{"location":"core-features/json-serialization/#pretty-printing","title":"Pretty Printing","text":"<p>Format JSON for easier reading:</p> <pre><code>require 'json'\n\nclass OrderMessage &lt; BunnyFarm::Message\n  def pretty_print\n    JSON.pretty_generate(@items)\n  end\nend\n\nputs message.pretty_print\n</code></pre> <p>Output: <pre><code>{\n  \"order_id\": 12345,\n  \"customer\": {\n    \"name\": \"John Doe\",\n    \"email\": \"john@example.com\"\n  },\n  \"items\": [\n    {\n      \"product_id\": 1,\n      \"quantity\": 2\n    }\n  ]\n}\n</code></pre></p>"},{"location":"core-features/json-serialization/#json-validation","title":"JSON Validation","text":"<p>Validate message structure:</p> <pre><code>require 'json-schema'\n\nclass ValidatedMessage &lt; BunnyFarm::Message\n  SCHEMA = {\n    type: 'object',\n    required: ['order_id', 'customer'],\n    properties: {\n      order_id: { type: 'integer' },\n      customer: {\n        type: 'object',\n        required: ['name', 'email'],\n        properties: {\n          name: { type: 'string' },\n          email: { type: 'string', format: 'email' }\n        }\n      }\n    }\n  }.freeze\n\n  def validate_schema\n    errors = JSON::Validator.fully_validate(SCHEMA, @items)\n    failure(\"Schema validation failed: #{errors.join(', ')}\") unless errors.empty?\n  end\nend\n</code></pre>"},{"location":"core-features/json-serialization/#message-inspection","title":"Message Inspection","text":"<p>Inspect messages in RabbitMQ management UI or with tools:</p> <pre><code># View message in RabbitMQ management interface\n# Messages tab \u2192 Get Messages \u2192 View JSON payload\n\n# Use rabbitmqadmin to inspect messages\nrabbitmqadmin get queue=order_queue requeue=true\n\n# Use jq to format JSON in command line\necho '{\"order_id\":12345,\"customer\":{\"name\":\"John\"}}' | jq '.'\n</code></pre>"},{"location":"core-features/json-serialization/#integration-patterns","title":"Integration Patterns","text":""},{"location":"core-features/json-serialization/#multi-language-consumers","title":"Multi-Language Consumers","text":"<p>Other languages can consume BunnyFarm messages:</p> <p>Python Consumer: <pre><code>import json\nimport pika\n\ndef process_order(channel, method, properties, body):\n    # Parse BunnyFarm JSON message\n    message_data = json.loads(body)\n    order_id = message_data['order_id']\n    customer = message_data['customer']\n\n    # Process order\n    print(f\"Processing order {order_id} for {customer['name']}\")\n\n    # Acknowledge message\n    channel.basic_ack(delivery_tag=method.delivery_tag)\n\n# Set up consumer\nconnection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))\nchannel = connection.channel()\nchannel.basic_consume(queue='order_queue', on_message_callback=process_order)\nchannel.start_consuming()\n</code></pre></p> <p>Node.js Consumer: <pre><code>const amqp = require('amqplib');\n\nasync function processOrders() {\n  const connection = await amqp.connect('amqp://localhost');\n  const channel = await connection.createChannel();\n\n  channel.consume('order_queue', (message) =&gt; {\n    // Parse BunnyFarm JSON message\n    const messageData = JSON.parse(message.content.toString());\n    const orderId = messageData.order_id;\n    const customer = messageData.customer;\n\n    console.log(`Processing order ${orderId} for ${customer.name}`);\n\n    // Acknowledge message\n    channel.ack(message);\n  });\n}\n</code></pre></p>"},{"location":"core-features/json-serialization/#api-gateway-integration","title":"API Gateway Integration","text":"<p>Expose message creation via REST API:</p> <pre><code>class OrdersController &lt; ApplicationController\n  def create\n    # Create message from API payload\n    order_message = OrderMessage.new\n    order_message[:order_id] = params[:order_id]\n    order_message[:customer] = params[:customer]\n    order_message[:items] = params[:items]\n\n    # Publish for processing\n    if order_message.publish('process')\n      render json: { status: 'accepted', order_id: params[:order_id] }\n    else\n      render json: { error: 'Failed to process order' }, status: 500\n    end\n  end\nend\n</code></pre>"},{"location":"core-features/json-serialization/#best-practices","title":"Best Practices","text":""},{"location":"core-features/json-serialization/#1-keep-messages-focused","title":"1. Keep Messages Focused","text":"<pre><code># Good: Focused message structure\nclass OrderMessage &lt; BunnyFarm::Message\n  fields :order_id, :customer_id, :items, :total, :shipping_address\nend\n\n# Avoid: Kitchen sink approach\nclass EverythingMessage &lt; BunnyFarm::Message\n  fields :order_data, :customer_data, :inventory_data, :shipping_data,\n         :payment_data, :analytics_data, :audit_data, :metadata\nend\n</code></pre>"},{"location":"core-features/json-serialization/#2-use-consistent-naming","title":"2. Use Consistent Naming","text":"<pre><code># Good: Consistent snake_case\n{\n  \"order_id\": 12345,\n  \"customer_email\": \"john@example.com\",\n  \"created_at\": \"2024-01-15T10:30:00Z\"\n}\n\n# Avoid: Mixed naming conventions\n{\n  \"orderId\": 12345,           # camelCase\n  \"customer_email\": \"john@example.com\",  # snake_case  \n  \"CreatedAt\": \"2024-01-15T10:30:00Z\"    # PascalCase\n}\n</code></pre>"},{"location":"core-features/json-serialization/#3-version-your-message-structure","title":"3. Version Your Message Structure","text":"<pre><code>class OrderMessage &lt; BunnyFarm::Message\n  def initialize\n    super\n    @items[:_version] = '1.0'\n  end\n\n  def process\n    case @items[:_version]\n    when '1.0'\n      process_v1\n    when '2.0'\n      process_v2\n    else\n      failure(\"Unsupported message version: #{@items[:_version]}\")\n    end\n  end\nend\n</code></pre>"},{"location":"core-features/json-serialization/#4-handle-missing-fields-gracefully","title":"4. Handle Missing Fields Gracefully","text":"<pre><code>def process\n  order_id = @items[:order_id]\n  return failure(\"Order ID required\") unless order_id\n\n  customer_email = @items.dig(:customer, :email)\n  return failure(\"Customer email required\") unless customer_email\n\n  # Process with validated data\n  success!\nend\n</code></pre>"},{"location":"core-features/json-serialization/#next-steps","title":"Next Steps","text":"<p>With JSON serialization mastered:</p> <ul> <li>Configure message formats for your environment</li> <li>Design message structures for optimal serialization</li> <li>Handle errors in serialization and deserialization</li> <li>Integrate with other systems using JSON</li> </ul>"},{"location":"core-features/message-design/","title":"Message-Centric Design","text":"<p>BunnyFarm's core philosophy revolves around treating messages as first-class objects that encapsulate both data and behavior. This approach provides a clean, object-oriented way to handle background job processing.</p>"},{"location":"core-features/message-design/#what-is-message-centric-design","title":"What is Message-Centric Design?","text":"<p>In traditional job queue systems, jobs are simple data structures passed to generic worker processes. BunnyFarm takes a different approach where each message type is a full Ruby class that defines:</p> <ul> <li>Data structure - What fields the message contains</li> <li>Business logic - What operations can be performed</li> <li>Error handling - How failures are managed</li> <li>State management - Success/failure tracking</li> </ul>"},{"location":"core-features/message-design/#benefits-of-message-classes","title":"Benefits of Message Classes","text":""},{"location":"core-features/message-design/#1-encapsulation","title":"1. Encapsulation","text":"<p>Related data and behavior stay together:</p> <pre><code>class OrderMessage &lt; BunnyFarm::Message\n  # Data structure\n  fields :order_id, :customer_email, :items\n\n  # Business logic\n  actions :validate, :process_payment, :ship\n\n  def validate\n    validate_order_data\n    validate_customer_info\n    success! if errors.empty?\n  end\n\n  def process_payment\n    # Payment logic here\n    success!\n  end\nend\n</code></pre>"},{"location":"core-features/message-design/#2-discoverability","title":"2. Discoverability","text":"<p>Easy to understand what a message can do:</p> <pre><code># Clear interface\nOrderMessage.new.respond_to?(:validate)    # =&gt; true\nOrderMessage.new.respond_to?(:ship)        # =&gt; true\nOrderMessage.new.respond_to?(:fly_rocket)  # =&gt; false\n</code></pre>"},{"location":"core-features/message-design/#3-testability","title":"3. Testability","text":"<p>Individual message types can be unit tested:</p> <pre><code>class TestOrderMessage &lt; Minitest::Test\n  def test_validation\n    message = OrderMessage.new\n    message[:order_id] = nil\n    message.validate\n\n    assert message.failed?\n    assert_includes message.errors, \"Order ID required\"\n  end\nend\n</code></pre>"},{"location":"core-features/message-design/#4-type-safety","title":"4. Type Safety","text":"<p>Ruby's class system provides structure:</p> <pre><code>class OrderMessage &lt; BunnyFarm::Message\n  fields :order_id, :customer_email\n\n  def validate\n    failure(\"Order ID required\") if @items[:order_id].nil?\n    failure(\"Invalid email\") unless valid_email?(@items[:customer_email])\n  end\n\n  private\n\n  def valid_email?(email)\n    email =~ /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n  end\nend\n</code></pre>"},{"location":"core-features/message-design/#message-anatomy","title":"Message Anatomy","text":"<p>Every BunnyFarm message has four key components:</p>"},{"location":"core-features/message-design/#1-class-definition","title":"1. Class Definition","text":"<p>Inherit from <code>BunnyFarm::Message</code>:</p> <pre><code>class CustomerMessage &lt; BunnyFarm::Message\n  # Message definition\nend\n</code></pre>"},{"location":"core-features/message-design/#2-fields-dsl","title":"2. Fields DSL","text":"<p>Define the data structure:</p> <pre><code>fields :name, :email, :phone,\n       { address: [:street, :city, :state, :zip] },\n       { preferences: [:newsletter, :marketing] }\n</code></pre>"},{"location":"core-features/message-design/#3-actions-dsl","title":"3. Actions DSL","text":"<p>Define available operations:</p> <pre><code>actions :register, :update_profile, :send_welcome_email\n</code></pre>"},{"location":"core-features/message-design/#4-action-methods","title":"4. Action Methods","text":"<p>Implement the business logic:</p> <pre><code>def register\n  validate_customer_data\n  return unless successful?\n\n  create_account\n  return unless successful?\n\n  send_welcome_email\nend\n</code></pre>"},{"location":"core-features/message-design/#design-patterns","title":"Design Patterns","text":""},{"location":"core-features/message-design/#command-pattern","title":"Command Pattern","text":"<p>Each action is a command that can be executed:</p> <pre><code>class ReportMessage &lt; BunnyFarm::Message\n  actions :generate, :email, :archive\n\n  def generate\n    # Generate report\n    @report_data = create_report\n    success!\n  end\n\n  def email\n    # Email the report\n    send_report_email(@report_data)\n    success!\n  end\nend\n\n# Usage\nreport = ReportMessage.new\nreport[:report_type] = 'monthly_sales'\nreport.publish('generate')  # Execute generate command\n</code></pre>"},{"location":"core-features/message-design/#state-machine-pattern","title":"State Machine Pattern","text":"<p>Messages can represent state transitions:</p> <pre><code>class OrderMessage &lt; BunnyFarm::Message\n  actions :place_order, :confirm_payment, :ship_order, :complete_order\n\n  def place_order\n    @items[:status] = 'pending'\n    validate_order\n    success!\n  end\n\n  def confirm_payment\n    return failure(\"Order not pending\") unless @items[:status] == 'pending'\n\n    @items[:status] = 'confirmed'\n    process_payment\n    success!\n  end\nend\n</code></pre>"},{"location":"core-features/message-design/#template-method-pattern","title":"Template Method Pattern","text":"<p>Define common workflow structure:</p> <pre><code>class ProcessingMessage &lt; BunnyFarm::Message\n  def process\n    validate_input\n    return unless successful?\n\n    perform_work\n    return unless successful?\n\n    finalize_result\n  end\n\n  private\n\n  # Subclasses override these methods\n  def validate_input; raise NotImplementedError; end\n  def perform_work; raise NotImplementedError; end  \n  def finalize_result; success!; end\nend\n\nclass OrderProcessingMessage &lt; ProcessingMessage\n  def validate_input\n    failure(\"Invalid order\") unless valid_order?\n  end\n\n  def perform_work\n    charge_payment\n    update_inventory\n  end\nend\n</code></pre>"},{"location":"core-features/message-design/#message-lifecycle","title":"Message Lifecycle","text":"<p>Understanding the message lifecycle helps design better message classes:</p>"},{"location":"core-features/message-design/#1-creation","title":"1. Creation","text":"<pre><code>message = OrderMessage.new\nmessage[:order_id] = 12345\nmessage[:customer_email] = 'customer@example.com'\n</code></pre>"},{"location":"core-features/message-design/#2-publishing","title":"2. Publishing","text":"<pre><code>message.publish('validate') # Routing key: OrderMessage.validate\n</code></pre>"},{"location":"core-features/message-design/#3-consumption","title":"3. Consumption","text":"<pre><code># Consumer receives message and calls validate method\ndef validate\n  # Business logic\n  success!\n  successful? # Returns true for ACK\nend\n</code></pre>"},{"location":"core-features/message-design/#4-acknowledgment","title":"4. Acknowledgment","text":"<ul> <li><code>true</code> return \u2192 Message acknowledged (ACK)</li> <li><code>false</code> return \u2192 Message rejected (NACK)</li> </ul>"},{"location":"core-features/message-design/#best-practices","title":"Best Practices","text":""},{"location":"core-features/message-design/#1-single-responsibility","title":"1. Single Responsibility","text":"<p>Each message class should handle one domain:</p> <pre><code># Good: Focused on orders\nclass OrderMessage &lt; BunnyFarm::Message\n  actions :validate, :process, :ship\nend\n\n# Avoid: Too broad\nclass EverythingMessage &lt; BunnyFarm::Message\n  actions :process_order, :send_email, :update_inventory, :generate_report\nend\n</code></pre>"},{"location":"core-features/message-design/#2-clear-action-names","title":"2. Clear Action Names","text":"<p>Use descriptive, verb-based action names:</p> <pre><code># Good: Clear intent\nactions :validate_order, :process_payment, :ship_order, :send_confirmation\n\n# Avoid: Vague names\nactions :do_stuff, :handle, :process\n</code></pre>"},{"location":"core-features/message-design/#3-proper-error-handling","title":"3. Proper Error Handling","text":"<p>Always handle errors gracefully:</p> <pre><code>def process_payment\n  return failure(\"No payment info\") unless payment_present?\n\n  begin\n    result = payment_gateway.charge(@items[:amount])\n\n    if result.success?\n      success!\n    else\n      failure(\"Payment failed: #{result.error_message}\")\n    end\n  rescue PaymentGatewayError =&gt; e\n    failure(\"Gateway error: #{e.message}\")\n  end\n\n  successful?\nend\n</code></pre>"},{"location":"core-features/message-design/#4-idempotent-operations","title":"4. Idempotent Operations","text":"<p>Make operations safe to retry:</p> <pre><code>def charge_payment\n  # Check if already processed\n  return success! if payment_already_charged?\n\n  # Process only if not done\n  result = charge_customer(@items[:amount])\n  result.success? ? success! : failure(result.error)\n\n  successful?\nend\n\nprivate\n\ndef payment_already_charged?\n  PaymentRecord.exists?(order_id: @items[:order_id])\nend\n</code></pre>"},{"location":"core-features/message-design/#5-meaningful-field-structures","title":"5. Meaningful Field Structures","text":"<p>Design clear, hierarchical data structures:</p> <pre><code># Good: Clear hierarchy\nfields :order_id, :total_amount,\n       { customer: [:name, :email, :phone] },\n       { billing_address: [:street, :city, :state, :zip] },\n       { items: [:product_id, :quantity, :unit_price] }\n\n# Avoid: Flat structure\nfields :order_id, :customer_name, :customer_email, :customer_phone,\n       :billing_street, :billing_city, :billing_state, :billing_zip\n</code></pre>"},{"location":"core-features/message-design/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"core-features/message-design/#message-inheritance","title":"Message Inheritance","text":"<p>Create base classes for common functionality:</p> <pre><code>class BaseProcessingMessage &lt; BunnyFarm::Message\n  def process\n    start_processing\n    perform_work\n    complete_processing\n  end\n\n  private\n\n  def start_processing\n    @items[:started_at] = Time.current\n  end\n\n  def complete_processing\n    @items[:completed_at] = Time.current\n    success!\n  end\n\n  def perform_work\n    raise NotImplementedError, \"Subclass must implement perform_work\"\n  end\nend\n\nclass OrderProcessingMessage &lt; BaseProcessingMessage\n  fields :order_id, :customer_id\n  actions :process\n\n  private\n\n  def perform_work\n    validate_order\n    charge_payment\n    update_inventory\n  end\nend\n</code></pre>"},{"location":"core-features/message-design/#message-composition","title":"Message Composition","text":"<p>Compose complex operations from simpler ones:</p> <pre><code>class OrderWorkflowMessage &lt; BunnyFarm::Message\n  actions :start_workflow\n\n  def start_workflow\n    # Chain multiple message types\n    validation_msg = OrderValidationMessage.new(@items)\n    validation_msg.publish('validate')\n\n    payment_msg = PaymentMessage.new(@items)\n    payment_msg.publish('charge')\n\n    shipping_msg = ShippingMessage.new(@items)\n    shipping_msg.publish('create_label')\n\n    success!\n  end\nend\n</code></pre>"},{"location":"core-features/message-design/#next-steps","title":"Next Steps","text":"<p>Now that you understand message-centric design:</p> <ul> <li>Smart Routing - How messages find their destination</li> <li>JSON Serialization - Data format and serialization</li> <li>Message Structure - Deep dive into implementation</li> </ul>"},{"location":"core-features/smart-routing/","title":"Smart Routing","text":"<p>BunnyFarm's smart routing system automatically creates predictable routing keys based on your message classes and actions. This eliminates the need for manual routing configuration while maintaining full transparency and debuggability.</p>"},{"location":"core-features/smart-routing/#how-smart-routing-works","title":"How Smart Routing Works","text":""},{"location":"core-features/smart-routing/#routing-key-pattern","title":"Routing Key Pattern","text":"<p>BunnyFarm uses a simple, predictable pattern for routing keys:</p> <pre><code>MessageClassName.action\n</code></pre> <p>Examples: - <code>OrderMessage.process</code>  - <code>EmailMessage.send</code> - <code>ReportMessage.generate</code> - <code>UserRegistrationMessage.create_account</code></p>"},{"location":"core-features/smart-routing/#automatic-generation","title":"Automatic Generation","text":"<p>When you publish a message, the routing key is automatically generated:</p> <pre><code>class OrderMessage &lt; BunnyFarm::Message\n  actions :validate, :process, :ship\nend\n\n# Publishing automatically creates routing keys\nmessage = OrderMessage.new\nmessage.publish('validate')  # Routing key: OrderMessage.validate\nmessage.publish('process')   # Routing key: OrderMessage.process\nmessage.publish('ship')      # Routing key: OrderMessage.ship\n</code></pre>"},{"location":"core-features/smart-routing/#routing-flow","title":"Routing Flow","text":""},{"location":"core-features/smart-routing/#1-publisher-side","title":"1. Publisher Side","text":"<pre><code># 1. Create message\norder_msg = OrderMessage.new\norder_msg[:order_id] = 12345\n\n# 2. Publish with action\norder_msg.publish('process')\n\n# 3. BunnyFarm generates routing key: \"OrderMessage.process\"\n# 4. Message sent to RabbitMQ with this routing key\n</code></pre>"},{"location":"core-features/smart-routing/#2-rabbitmq-routing","title":"2. RabbitMQ Routing","text":"<pre><code>Publisher \u2192 Exchange \u2192 Queue(s) \u2192 Consumer(s)\n            \u2191\n    Routes based on\n    \"OrderMessage.process\"\n</code></pre>"},{"location":"core-features/smart-routing/#3-consumer-side","title":"3. Consumer Side","text":"<pre><code># 1. Consumer receives message with routing key \"OrderMessage.process\"\n# 2. BunnyFarm parses routing key \u2192 class: OrderMessage, action: process  \n# 3. Message deserialized to OrderMessage instance\n# 4. The 'process' method is called automatically\n\nclass OrderMessage &lt; BunnyFarm::Message\n  def process\n    # This method is called automatically\n    puts \"Processing order #{@items[:order_id]}\"\n    success!\n  end\nend\n</code></pre>"},{"location":"core-features/smart-routing/#exchange-and-queue-configuration","title":"Exchange and Queue Configuration","text":""},{"location":"core-features/smart-routing/#topic-exchange","title":"Topic Exchange","text":"<p>BunnyFarm typically uses RabbitMQ's topic exchange for flexible routing:</p> <pre><code>BunnyFarm.config do\n  exchange_name 'bunny_farm_exchange'\n  exchange_type :topic  # Supports pattern matching\nend\n</code></pre>"},{"location":"core-features/smart-routing/#queue-bindings","title":"Queue Bindings","text":"<p>Queues can bind to specific routing patterns:</p> <pre><code># Bind to all OrderMessage actions\nqueue.bind(exchange, routing_key: 'OrderMessage.*')\n\n# Bind to specific actions only\nqueue.bind(exchange, routing_key: 'OrderMessage.process')\n\n# Bind to all messages\nqueue.bind(exchange, routing_key: '#')\n\n# Bind to all validation actions across message types\nqueue.bind(exchange, routing_key: '*.validate')\n</code></pre>"},{"location":"core-features/smart-routing/#routing-patterns","title":"Routing Patterns","text":""},{"location":"core-features/smart-routing/#1-single-message-type-single-action","title":"1. Single Message Type, Single Action","text":"<p>Use case: Dedicated worker for specific operations</p> <pre><code># Worker specializes in order processing\nBunnyFarm.config do\n  queue_name 'order_processing'\n  routing_key 'OrderMessage.process'\nend\n\n# Only processes OrderMessage.process\nBunnyFarm.manage\n</code></pre>"},{"location":"core-features/smart-routing/#2-single-message-type-multiple-actions","title":"2. Single Message Type, Multiple Actions","text":"<p>Use case: Worker handles all operations for one domain</p> <pre><code># Worker handles all order operations\nBunnyFarm.config do\n  queue_name 'order_worker'\n  routing_key 'OrderMessage.*'  # All OrderMessage actions\nend\n\nclass OrderMessage &lt; BunnyFarm::Message\n  actions :validate, :process, :ship, :cancel\n\n  def validate; end    # Handled by order_worker\n  def process; end     # Handled by order_worker\n  def ship; end        # Handled by order_worker\n  def cancel; end      # Handled by order_worker\nend\n</code></pre>"},{"location":"core-features/smart-routing/#3-multiple-message-types-specific-actions","title":"3. Multiple Message Types, Specific Actions","text":"<p>Use case: Worker specializes in one type of operation across domains</p> <pre><code># Worker handles validation for all message types\nBunnyFarm.config do\n  queue_name 'validation_worker'\n  routing_key '*.validate'  # All validation actions\nend\n\n# These would all be handled by validation_worker:\n# OrderMessage.validate\n# CustomerMessage.validate  \n# ProductMessage.validate\n</code></pre>"},{"location":"core-features/smart-routing/#4-multiple-message-types-all-actions","title":"4. Multiple Message Types, All Actions","text":"<p>Use case: General-purpose worker</p> <pre><code># Worker handles everything\nBunnyFarm.config do\n  queue_name 'general_worker'\n  routing_key '#'  # All messages\nend\n</code></pre>"},{"location":"core-features/smart-routing/#advanced-routing-scenarios","title":"Advanced Routing Scenarios","text":""},{"location":"core-features/smart-routing/#priority-queues","title":"Priority Queues","text":"<p>Route urgent messages to high-priority queues:</p> <pre><code>class UrgentOrderMessage &lt; BunnyFarm::Message\n  actions :process_immediately\nend\n\n# High-priority worker\nBunnyFarm.config do\n  queue_name 'urgent_orders'\n  routing_key 'UrgentOrderMessage.*'\n  queue_options do\n    arguments 'x-max-priority' =&gt; 10\n  end\nend\n\n# Regular priority worker\nBunnyFarm.config do\n  queue_name 'regular_orders'  \n  routing_key 'OrderMessage.*'\nend\n</code></pre>"},{"location":"core-features/smart-routing/#geographic-routing","title":"Geographic Routing","text":"<p>Route messages based on regions:</p> <pre><code>class USOrderMessage &lt; BunnyFarm::Message\n  actions :process, :ship\nend\n\nclass EUOrderMessage &lt; BunnyFarm::Message\n  actions :process, :ship\nend\n\n# US worker\nBunnyFarm.config do\n  queue_name 'us_orders'\n  routing_key 'USOrderMessage.*'\nend\n\n# EU worker\nBunnyFarm.config do\n  queue_name 'eu_orders'\n  routing_key 'EUOrderMessage.*'\nend\n</code></pre>"},{"location":"core-features/smart-routing/#load-balancing","title":"Load Balancing","text":"<p>Multiple workers can consume from the same queue:</p> <pre><code># Worker 1\nBunnyFarm.config do\n  app_id 'worker_1'\n  queue_name 'order_processing'\n  routing_key 'OrderMessage.process'\nend\n\n# Worker 2  \nBunnyFarm.config do\n  app_id 'worker_2'\n  queue_name 'order_processing'  # Same queue\n  routing_key 'OrderMessage.process'\nend\n\n# RabbitMQ automatically load balances between workers\n</code></pre>"},{"location":"core-features/smart-routing/#routing-key-introspection","title":"Routing Key Introspection","text":""},{"location":"core-features/smart-routing/#debugging-routing","title":"Debugging Routing","text":"<p>Check what routing key will be generated:</p> <pre><code>class OrderMessage &lt; BunnyFarm::Message\n  actions :process\nend\n\nmessage = OrderMessage.new\nrouting_key = \"#{message.class.name}.process\"\nputs routing_key  # =&gt; \"OrderMessage.process\"\n</code></pre>"},{"location":"core-features/smart-routing/#runtime-routing-information","title":"Runtime Routing Information","text":"<p>Access routing information during processing:</p> <pre><code>class OrderMessage &lt; BunnyFarm::Message\n  def process\n    puts \"Processing with routing key: #{self.class.name}.process\"\n    puts \"Message class: #{self.class.name}\"\n    puts \"Action: process\"\n\n    success!\n  end\nend\n</code></pre>"},{"location":"core-features/smart-routing/#error-routing","title":"Error Routing","text":""},{"location":"core-features/smart-routing/#dead-letter-queues","title":"Dead Letter Queues","text":"<p>Failed messages can be routed to error queues:</p> <pre><code>BunnyFarm.config do\n  queue_name 'order_processing'\n  routing_key 'OrderMessage.*'\n\n  queue_options do\n    arguments({\n      'x-dead-letter-exchange' =&gt; 'failed_messages',\n      'x-dead-letter-routing-key' =&gt; 'failed.OrderMessage'\n    })\n  end\nend\n</code></pre>"},{"location":"core-features/smart-routing/#retry-queues","title":"Retry Queues","text":"<p>Implement retry logic with delayed routing:</p> <pre><code>class OrderMessage &lt; BunnyFarm::Message\n  def process\n    begin\n      perform_processing\n      success!\n    rescue RetryableError =&gt; e\n      if retry_count &lt; 3\n        # Publish to retry queue with delay\n        retry_message = self.class.new(@items)\n        retry_message[:retry_count] = retry_count + 1\n        retry_message.publish_delayed('process', delay: 30.seconds)\n        success!  # Don't NACK original message\n      else\n        failure(\"Max retries exceeded: #{e.message}\")\n      end\n    end\n\n    successful?\n  end\n\n  private\n\n  def retry_count\n    @items[:retry_count] || 0\n  end\nend\n</code></pre>"},{"location":"core-features/smart-routing/#monitoring-and-debugging","title":"Monitoring and Debugging","text":""},{"location":"core-features/smart-routing/#rabbitmq-management-ui","title":"RabbitMQ Management UI","text":"<p>Use RabbitMQ's management interface to monitor routing:</p> <ol> <li>Exchanges tab - See message routing statistics</li> <li>Queues tab - Monitor queue depths and consumption rates</li> <li>Connections tab - View active publishers and consumers</li> </ol>"},{"location":"core-features/smart-routing/#routing-metrics","title":"Routing Metrics","text":"<p>Track routing patterns in your application:</p> <pre><code>class OrderMessage &lt; BunnyFarm::Message\n  def process\n    # Track routing metrics\n    Metrics.increment(\"message.routed.#{self.class.name}.process\")\n\n    # Your processing logic\n    perform_order_processing\n\n    Metrics.increment(\"message.processed.#{self.class.name}.process\")\n    success!\n  end\nend\n</code></pre>"},{"location":"core-features/smart-routing/#logging-routing-events","title":"Logging Routing Events","text":"<p>Log routing information for debugging:</p> <pre><code>class OrderMessage &lt; BunnyFarm::Message\n  def process\n    logger.info \"Processing message\",\n                routing_key: \"#{self.class.name}.process\",\n                message_id: @items[:order_id]\n\n    # Processing logic\n    success!\n  end\nend\n</code></pre>"},{"location":"core-features/smart-routing/#best-practices","title":"Best Practices","text":""},{"location":"core-features/smart-routing/#1-predictable-naming","title":"1. Predictable Naming","text":"<p>Use clear, consistent class and action names:</p> <pre><code># Good: Clear domain and action\nclass CustomerRegistrationMessage &lt; BunnyFarm::Message\n  actions :validate_email, :create_account, :send_welcome\nend\n\n# Avoid: Vague or abbreviated names\nclass CRM &lt; BunnyFarm::Message\n  actions :val, :cr8, :snd\nend\n</code></pre>"},{"location":"core-features/smart-routing/#2-logical-grouping","title":"2. Logical Grouping","text":"<p>Group related actions in the same message class:</p> <pre><code># Good: Related order operations\nclass OrderMessage &lt; BunnyFarm::Message  \n  actions :validate, :process_payment, :fulfill, :ship, :complete\nend\n\n# Avoid: Mixing unrelated operations\nclass MixedMessage &lt; BunnyFarm::Message\n  actions :process_order, :send_email, :backup_database, :clean_temp_files\nend\n</code></pre>"},{"location":"core-features/smart-routing/#3-queue-design","title":"3. Queue Design","text":"<p>Design queues around processing capabilities:</p> <pre><code># Good: Separate concerns\nBunnyFarm.config do\n  case worker_type\n  when 'payment_processor'\n    routing_key '*.process_payment'\n  when 'email_sender'\n    routing_key '*.send_email'\n  when 'order_validator'\n    routing_key 'OrderMessage.validate'\n  end\nend\n</code></pre>"},{"location":"core-features/smart-routing/#4-error-handling","title":"4. Error Handling","text":"<p>Plan for routing errors:</p> <pre><code>def process\n  validate_message_structure\n  return unless successful?\n\n  perform_business_logic\n  return unless successful?\n\n  log_success\nend\n\nprivate\n\ndef validate_message_structure\n  required_fields = [:order_id, :customer_id, :amount]\n  missing = required_fields.select { |field| @items[field].nil? }\n\n  failure(\"Missing required fields: #{missing.join(', ')}\") if missing.any?\nend\n</code></pre>"},{"location":"core-features/smart-routing/#next-steps","title":"Next Steps","text":"<p>Understanding smart routing enables you to:</p> <ul> <li>Configure routing for your specific needs</li> <li>Design message structures that route effectively  </li> <li>Scale your architecture with proper queue design</li> <li>Handle errors with appropriate routing strategies</li> </ul>"},{"location":"core-features/task-scheduling/","title":"Task Scheduling","text":"<p>BunnyFarm supports delayed message processing and task scheduling, allowing you to build sophisticated time-based workflows and recurring operations.</p> <p></p>"},{"location":"core-features/task-scheduling/#delayed-messages","title":"Delayed Messages","text":"<pre><code>class ScheduledTask &lt; BunnyFarm::Message\n  actions :schedule, :execute\n\n  def schedule\n    # Schedule execution for later\n    delay_seconds = @items[:delay] || 3600  # 1 hour default\n\n    # Use RabbitMQ delayed message plugin or custom delay queue\n    publish_delayed('execute', delay: delay_seconds)\n    success!\n  end\n\n  def execute\n    puts \"Executing scheduled task at #{Time.current}\"\n    perform_scheduled_work\n    success!\n  end\nend\n</code></pre>"},{"location":"core-features/task-scheduling/#recurring-tasks","title":"Recurring Tasks","text":"<pre><code>def execute_recurring\n  perform_work\n\n  # Schedule next execution\n  next_run = @items[:interval] || 3600  # 1 hour\n  self.class.new(@items).publish_delayed('execute_recurring', delay: next_run)\n\n  success!\nend\n</code></pre>"},{"location":"core-features/task-scheduling/#retry-patterns","title":"Retry Patterns","text":"<pre><code>def execute_with_retry\n  begin\n    risky_operation\n    success!\n  rescue =&gt; e\n    retry_count = (@items[:retry_count] || 0) + 1\n\n    if retry_count &lt; 3\n      delay = 2 ** retry_count  # Exponential backoff\n\n      retry_msg = self.class.new(@items)\n      retry_msg[:retry_count] = retry_count\n      retry_msg.publish_delayed('execute_with_retry', delay: delay)\n\n      success!\n    else\n      failure(\"Max retries exceeded: #{e.message}\")\n    end\n  end\nend\n</code></pre>"},{"location":"core-features/workflow-support/","title":"Workflow Support","text":"<p>BunnyFarm excels at building complex, multi-step workflows where messages can trigger subsequent operations, creating sophisticated business processes through message chaining and coordination.</p> <p></p>"},{"location":"core-features/workflow-support/#workflow-patterns","title":"Workflow Patterns","text":""},{"location":"core-features/workflow-support/#sequential-workflows","title":"Sequential Workflows","text":"<p>Messages can trigger follow-up messages in sequence:</p> <pre><code>class OrderWorkflow &lt; BunnyFarm::Message\n  actions :start_order, :validate, :process_payment, :fulfill, :ship, :complete\n\n  def start_order\n    # Step 1: Validate order\n    self.class.new(@items).publish('validate')\n    success!\n  end\n\n  def validate\n    validate_order_data\n    return unless successful?\n\n    # Step 2: Process payment\n    self.class.new(@items).publish('process_payment')\n    success!\n  end\n\n  def process_payment\n    charge_customer\n    return unless successful?\n\n    # Step 3: Fulfill order\n    self.class.new(@items).publish('fulfill')\n    success!\n  end\nend\n</code></pre>"},{"location":"core-features/workflow-support/#conditional-workflows","title":"Conditional Workflows","text":"<pre><code>def process_order\n  validate_order\n  return unless successful?\n\n  if @items[:requires_approval]\n    self.class.new(@items).publish('request_approval')\n  else\n    self.class.new(@items).publish('auto_process')\n  end\n\n  success!\nend\n</code></pre>"},{"location":"core-features/workflow-support/#parallel-workflows","title":"Parallel Workflows","text":"<pre><code>def start_parallel_processing\n  # Trigger multiple parallel operations\n  InventoryMessage.new(@items).publish('reserve_items')\n  PaymentMessage.new(@items).publish('authorize_payment')\n  ShippingMessage.new(@items).publish('calculate_shipping')\n\n  success!\nend\n</code></pre>"},{"location":"core-features/workflow-support/#state-management","title":"State Management","text":""},{"location":"core-features/workflow-support/#workflow-state-tracking","title":"Workflow State Tracking","text":"<pre><code>class OrderWorkflow &lt; BunnyFarm::Message\n  def initialize\n    super\n    @items[:workflow_state] = 'initialized'\n    @items[:completed_steps] = []\n  end\n\n  def validate\n    @items[:workflow_state] = 'validating'\n\n    perform_validation\n\n    if successful?\n      @items[:completed_steps] &lt;&lt; 'validate'\n      @items[:workflow_state] = 'validated'\n      trigger_next_step\n    end\n  end\n\n  private\n\n  def trigger_next_step\n    case @items[:workflow_state]\n    when 'validated'\n      self.class.new(@items).publish('process_payment')\n    when 'payment_processed'\n      self.class.new(@items).publish('fulfill')\n    end\n  end\nend\n</code></pre>"},{"location":"core-features/workflow-support/#next-steps","title":"Next Steps","text":"<p>Workflows enable complex business processes through message orchestration.</p>"},{"location":"development/contributing/","title":"Contributing to BunnyFarm","text":"<p>We welcome contributions to BunnyFarm! This guide will help you get started with contributing code, documentation, and other improvements.</p>"},{"location":"development/contributing/#getting-started","title":"Getting Started","text":""},{"location":"development/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Ruby 2.5 or higher</li> <li>RabbitMQ server for testing</li> <li>Git for version control</li> <li>Bundler for dependency management</li> </ul>"},{"location":"development/contributing/#setting-up-development-environment","title":"Setting Up Development Environment","text":"<ol> <li>Fork the repository on GitHub</li> <li> <p>Clone your fork locally:    <pre><code>git clone https://github.com/YOUR_USERNAME/bunny_farm.git\ncd bunny_farm\n</code></pre></p> </li> <li> <p>Install dependencies:    <pre><code>bundle install\n</code></pre></p> </li> <li> <p>Set up RabbitMQ for testing:    <pre><code># macOS with Homebrew\nbrew install rabbitmq\nbrew services start rabbitmq\n\n# Ubuntu/Debian\nsudo apt-get install rabbitmq-server\nsudo systemctl start rabbitmq-server\n</code></pre></p> </li> <li> <p>Run the tests to ensure everything works:    <pre><code>bundle exec rake test\n</code></pre></p> </li> </ol>"},{"location":"development/contributing/#development-philosophy","title":"Development Philosophy","text":"<p>BunnyFarm follows the K.I.S.S. (Keep It Simple, Stupid) design principle:</p> <ul> <li>Simplicity over complexity - Choose simple solutions over elaborate ones</li> <li>Clarity over cleverness - Write code that's easy to understand</li> <li>Convention over configuration - Provide sensible defaults</li> <li>Edge cases are not priorities - Focus on common use cases</li> </ul>"},{"location":"development/contributing/#code-style-guidelines","title":"Code Style Guidelines","text":""},{"location":"development/contributing/#ruby-style","title":"Ruby Style","text":"<p>Follow standard Ruby conventions:</p> <pre><code># Good: Clear, descriptive names\nclass OrderProcessingMessage &lt; BunnyFarm::Message\n  fields :order_id, :customer_email, :items\n  actions :validate, :process, :ship\n\n  def validate\n    validate_order_data\n    validate_customer_info\n    success! if errors.empty?\n  end\nend\n\n# Avoid: Unclear or overly clever code\nclass OPM &lt; BF::Msg\n  flds :oid, :ce, :its\n  acts :v, :p, :s\n\n  def v; vod; vci; suc! if ers.empty?; end\nend\n</code></pre>"},{"location":"development/contributing/#documentation-style","title":"Documentation Style","text":"<ul> <li>Clear examples - Provide runnable code examples</li> <li>Practical focus - Show real-world usage patterns  </li> <li>Progressive complexity - Start simple, build up</li> <li>Consistent format - Follow established patterns</li> </ul>"},{"location":"development/contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"development/contributing/#bug-fixes","title":"\ud83d\udc1b Bug Fixes","text":"<p>Found a bug? We'd love your help fixing it!</p> <ol> <li>Search existing issues to avoid duplicates</li> <li>Create an issue describing the bug with:</li> <li>Ruby version</li> <li>BunnyFarm version</li> <li>RabbitMQ version</li> <li>Minimal reproduction case</li> <li>Expected vs actual behavior</li> <li>Submit a pull request with the fix</li> </ol>"},{"location":"development/contributing/#feature-additions","title":"\u2728 Feature Additions","text":"<p>Have an idea for a new feature?</p> <ol> <li>Discuss first - Open an issue to discuss the feature</li> <li>Keep it simple - Align with BunnyFarm's philosophy</li> <li>Consider the common case - Focus on widely useful features</li> <li>Include tests - New features need test coverage</li> <li>Update documentation - Include usage examples</li> </ol>"},{"location":"development/contributing/#documentation-improvements","title":"\ud83d\udcda Documentation Improvements","text":"<p>Documentation improvements are always welcome:</p> <ul> <li>Fix typos and grammar</li> <li>Add missing examples</li> <li>Clarify confusing sections</li> <li>Create new guides and tutorials</li> <li>Update API documentation</li> </ul>"},{"location":"development/contributing/#testing-enhancements","title":"\ud83e\uddea Testing Enhancements","text":"<p>Help improve test coverage:</p> <ul> <li>Add missing test cases</li> <li>Improve test reliability</li> <li>Add integration tests</li> <li>Performance testing</li> <li>Cross-platform testing</li> </ul>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"development/contributing/#before-submitting","title":"Before Submitting","text":"<ol> <li> <p>Run the tests:    <pre><code>bundle exec rake test\n</code></pre></p> </li> <li> <p>Check code style:    <pre><code>bundle exec rubocop\n</code></pre></p> </li> <li> <p>Update documentation if needed</p> </li> <li> <p>Add tests for new functionality</p> </li> </ol>"},{"location":"development/contributing/#submitting-your-pr","title":"Submitting Your PR","text":"<ol> <li> <p>Create a feature branch:    <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> <li> <p>Make your changes with clear, atomic commits:    <pre><code>git commit -m \"Add message retry functionality\"\n</code></pre></p> </li> <li> <p>Push to your fork:    <pre><code>git push origin feature/your-feature-name\n</code></pre></p> </li> <li> <p>Create a pull request with:</p> </li> <li>Clear title describing the change</li> <li>Detailed description of what was changed and why</li> <li>Link to related issues</li> <li>Screenshots/examples if applicable</li> </ol>"},{"location":"development/contributing/#pr-review-process","title":"PR Review Process","text":"<ol> <li>Automated checks run (tests, style, etc.)</li> <li>Maintainer review - We'll provide feedback</li> <li>Address feedback - Make requested changes</li> <li>Final review - Maintainer approval</li> <li>Merge - Your contribution is included!</li> </ol>"},{"location":"development/contributing/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"development/contributing/#writing-tests","title":"Writing Tests","text":"<p>BunnyFarm uses Minitest for testing. Follow these patterns:</p> <pre><code># test/test_your_feature.rb\nrequire 'minitest_helper'\n\nclass TestYourFeature &lt; Minitest::Test\n  def setup\n    @message = TestMessage.new\n  end\n\n  def test_basic_functionality\n    @message[:field] = 'value'\n    @message.your_action\n\n    assert @message.successful?\n  end\n\n  def test_error_handling\n    @message[:field] = nil # Invalid value\n    @message.your_action\n\n    assert @message.failed?\n    assert_includes @message.errors, 'Field is required'\n  end\nend\n</code></pre>"},{"location":"development/contributing/#test-organization","title":"Test Organization","text":"<ul> <li>Unit tests - Test individual methods and classes</li> <li>Integration tests - Test end-to-end message flows</li> <li>Performance tests - Verify performance characteristics</li> <li>Edge case tests - Test boundary conditions</li> </ul>"},{"location":"development/contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\nbundle exec rake test\n\n# Run specific test file\nbundle exec ruby test/test_message.rb\n\n# Run specific test method\nbundle exec ruby test/test_message.rb -n test_basic_functionality\n</code></pre>"},{"location":"development/contributing/#issue-reporting","title":"Issue Reporting","text":""},{"location":"development/contributing/#bug-reports","title":"Bug Reports","text":"<p>When reporting bugs, include:</p> <pre><code>**Bug Description**\nClear description of the bug\n\n**Environment**\n- Ruby version: X.X.X\n- BunnyFarm version: X.X.X\n- RabbitMQ version: X.X.X\n- OS: macOS/Linux/Windows\n\n**Reproduction Steps**\n1. Step one\n2. Step two\n3. Bug occurs\n\n**Expected Behavior**\nWhat should happen\n\n**Actual Behavior**\nWhat actually happens\n\n**Minimal Code Example**\n```ruby\n# Code that reproduces the bug\n</code></pre>"},{"location":"development/contributing/#feature-requests","title":"Feature Requests","text":"<p>For feature requests, provide:</p> <ul> <li>Use case - What problem does this solve?</li> <li>Proposed solution - How should it work?</li> <li>Alternatives considered - What other approaches did you consider?</li> <li>Examples - Show how it would be used</li> </ul>"},{"location":"development/contributing/#code-review-guidelines","title":"Code Review Guidelines","text":""},{"location":"development/contributing/#for-contributors","title":"For Contributors","text":"<ul> <li>Keep PRs focused - One feature/fix per PR</li> <li>Write clear commit messages - Explain what and why</li> <li>Be responsive - Address feedback promptly</li> <li>Test thoroughly - Ensure changes work correctly</li> </ul>"},{"location":"development/contributing/#for-reviewers","title":"For Reviewers","text":"<ul> <li>Be constructive - Provide helpful feedback</li> <li>Focus on the code - Not the person</li> <li>Explain reasoning - Help contributors learn</li> <li>Recognize good work - Acknowledge quality contributions</li> </ul>"},{"location":"development/contributing/#release-process","title":"Release Process","text":"<p>BunnyFarm follows semantic versioning:</p> <ul> <li>Major version (X.0.0) - Breaking changes</li> <li>Minor version (0.X.0) - New features, backwards compatible</li> <li>Patch version (0.0.X) - Bug fixes, backwards compatible</li> </ul>"},{"location":"development/contributing/#release-criteria","title":"Release Criteria","text":"<ul> <li>All tests passing</li> <li>Documentation updated</li> <li>CHANGELOG.md updated</li> <li>Version number updated</li> </ul>"},{"location":"development/contributing/#community-guidelines","title":"Community Guidelines","text":""},{"location":"development/contributing/#be-respectful","title":"Be Respectful","text":"<ul> <li>Inclusive environment - Welcome contributors of all backgrounds</li> <li>Professional communication - Keep discussions constructive</li> <li>Patient teaching - Help newcomers learn</li> </ul>"},{"location":"development/contributing/#be-helpful","title":"Be Helpful","text":"<ul> <li>Answer questions - Help other users and contributors</li> <li>Share knowledge - Contribute to discussions</li> <li>Mentor newcomers - Guide new contributors</li> </ul>"},{"location":"development/contributing/#getting-help","title":"Getting Help","text":"<p>Need help contributing? Reach out:</p> <ul> <li>GitHub Issues - For bugs and feature requests</li> <li>GitHub Discussions - For questions and general discussion</li> <li>Pull Request Comments - For specific code feedback</li> </ul>"},{"location":"development/contributing/#recognition","title":"Recognition","text":"<p>Contributors are recognized in:</p> <ul> <li>CHANGELOG.md - For significant contributions</li> <li>README.md - In the contributors section</li> <li>Release notes - For notable features and fixes</li> </ul>"},{"location":"development/contributing/#next-steps","title":"Next Steps","text":"<p>Ready to contribute?</p> <ol> <li>Browse open issues - Find something to work on</li> <li>Join discussions - Participate in the community</li> <li>Start small - Begin with documentation or small bug fixes</li> <li>Ask questions - Don't hesitate to ask for help</li> </ol> <p>Thank you for contributing to BunnyFarm! \ud83d\udc30</p>"},{"location":"development/roadmap/","title":"Roadmap","text":"<p>Future development plans for BunnyFarm.</p>"},{"location":"development/roadmap/#upcoming-features","title":"Upcoming Features","text":"<ul> <li>Enhanced monitoring</li> <li>Performance improvements</li> <li>Additional adapters</li> <li>Better debugging tools</li> </ul>"},{"location":"development/testing/","title":"Testing","text":"<p>Testing strategies for BunnyFarm applications.</p>"},{"location":"development/testing/#unit-testing","title":"Unit Testing","text":"<pre><code>class TestOrderMessage &lt; Minitest::Test\n  def test_validation\n    message = OrderMessage.new\n    message.validate\n    assert message.successful?\n  end\nend\n</code></pre>"},{"location":"examples/order-processing/","title":"Order Processing Example","text":"<p>Comprehensive e-commerce order processing workflow.</p> <pre><code>class OrderMessage &lt; BunnyFarm::Message\n  fields :order_id, :customer, :items\n  actions :validate, :process, :ship\nend\n</code></pre>"},{"location":"examples/overview/","title":"Examples Overview","text":"<p>This section provides comprehensive, runnable examples that demonstrate BunnyFarm's capabilities. Each example includes complete code, setup instructions, and explanation of concepts.</p>"},{"location":"examples/overview/#available-examples","title":"Available Examples","text":""},{"location":"examples/overview/#simple-producerconsumer","title":"\ud83d\ude80 Simple Producer/Consumer","text":"<p>Perfect for getting started. Shows the basic patterns of message creation, publishing, and consumption.</p> <p>What you'll learn: - Basic message class creation - Publishing messages - Setting up consumers - Message routing</p> <p>Use cases: - Background job processing - Simple task queues - Event notifications</p>"},{"location":"examples/overview/#order-processing-workflow","title":"\ud83d\udce6 Order Processing Workflow","text":"<p>A comprehensive e-commerce order processing system with multiple steps, error handling, and workflow management.</p> <p>What you'll learn: - Complex message workflows - Multi-step processing - Error handling and recovery - State transitions - Success/failure tracking</p> <p>Use cases: - E-commerce order processing - Multi-step business workflows - Complex validation chains - Payment processing</p>"},{"location":"examples/overview/#task-scheduler","title":"\u23f0 Task Scheduler","text":"<p>Advanced example showing scheduled task execution, retry logic, and failure recovery patterns.</p> <p>What you'll learn: - Delayed message processing - Retry mechanisms with exponential backoff - Dead letter queue handling - Monitoring and alerting - Batch processing</p> <p>Use cases: - Scheduled report generation - Recurring maintenance tasks - Email campaigns - Data synchronization</p>"},{"location":"examples/overview/#real-world-examples","title":"\ud83c\udf0d Real World Examples","text":"<p>Production-ready examples from real applications showing advanced patterns and best practices.</p> <p>What you'll learn: - Production configuration - Monitoring and logging - Performance optimization - Error tracking - Deployment patterns</p> <p>Use cases: - Microservice communication - Event-driven architecture - Data pipeline processing - System integration</p>"},{"location":"examples/overview/#getting-started-with-examples","title":"Getting Started with Examples","text":""},{"location":"examples/overview/#prerequisites","title":"Prerequisites","text":"<p>Before running any examples, ensure you have:</p> <ol> <li>BunnyFarm installed: <code>gem install bunny_farm</code></li> <li>RabbitMQ running: Local or remote instance</li> <li>Ruby 2.5+: Compatible Ruby version</li> </ol>"},{"location":"examples/overview/#environment-setup","title":"Environment Setup","text":"<p>Set up your environment variables:</p> <pre><code>export AMQP_HOST=localhost\nexport AMQP_VHOST=/\nexport AMQP_PORT=5672\nexport AMQP_USER=guest\nexport AMQP_PASS=guest\nexport AMQP_EXCHANGE=bunny_farm_examples\nexport AMQP_QUEUE=example_queue\nexport AMQP_ROUTING_KEY='#'\nexport AMQP_APP_NAME=example_app\n</code></pre>"},{"location":"examples/overview/#running-examples","title":"Running Examples","text":"<p>Each example includes:</p> <ol> <li>Complete source code - Copy-paste ready</li> <li>Setup instructions - Step-by-step guide</li> <li>Expected output - What you should see</li> <li>Troubleshooting - Common issues and solutions</li> <li>Variations - Alternative implementations</li> </ol>"},{"location":"examples/overview/#example-structure","title":"Example Structure","text":"<p>All examples follow a consistent structure:</p> <pre><code>example_name/\n\u251c\u2500\u2500 README.md           # Setup and usage instructions\n\u251c\u2500\u2500 message_class.rb    # Message definition\n\u251c\u2500\u2500 producer.rb         # Message publisher\n\u251c\u2500\u2500 consumer.rb         # Message processor\n\u2514\u2500\u2500 config.rb          # Configuration (if needed)\n</code></pre>"},{"location":"examples/overview/#architecture-patterns","title":"Architecture Patterns","text":"<p>The examples demonstrate key architectural patterns:</p>"},{"location":"examples/overview/#producer-consumer-pattern","title":"Producer-Consumer Pattern","text":"<pre><code># Producer\nmessage = OrderMessage.new\nmessage[:order_id] = 12345\nmessage.publish('process')\n\n# Consumer  \nBunnyFarm.manage # Process incoming messages\n</code></pre>"},{"location":"examples/overview/#workflow-pattern","title":"Workflow Pattern","text":"<pre><code>def process_order\n  validate_order\n  return unless successful?\n\n  charge_payment  \n  return unless successful?\n\n  ship_order\n  return unless successful?\n\n  send_confirmation\nend\n</code></pre>"},{"location":"examples/overview/#retry-pattern","title":"Retry Pattern","text":"<pre><code>def risky_operation\n  retries = 0\n  begin\n    perform_operation\n    success!\n  rescue =&gt; e\n    retries += 1\n    if retries &lt; 3\n      sleep(2 ** retries) # Exponential backoff\n      retry\n    else\n      failure(\"Failed after 3 attempts: #{e.message}\")\n    end\n  end\nend\n</code></pre>"},{"location":"examples/overview/#testing-examples","title":"Testing Examples","text":"<p>Each example includes test scenarios:</p>"},{"location":"examples/overview/#unit-testing","title":"Unit Testing","text":"<pre><code># Test message behavior\nmessage = OrderMessage.new\nmessage[:order_id] = 123\nmessage.validate_order\n\nassert message.successful?\n</code></pre>"},{"location":"examples/overview/#integration-testing","title":"Integration Testing","text":"<pre><code># Test end-to-end flow\nproducer.publish_order(order_data)\nconsumer.process_next_message\nassert_order_processed(order_data[:id])\n</code></pre>"},{"location":"examples/overview/#common-patterns","title":"Common Patterns","text":""},{"location":"examples/overview/#configuration-management","title":"Configuration Management","text":"<pre><code>BunnyFarm.config do\n  case ENV['RAILS_ENV']\n  when 'production'\n    env 'production'  \n    bunny_file 'config/rabbitmq.yml'\n  when 'development'\n    # Use defaults\n  end\nend\n</code></pre>"},{"location":"examples/overview/#error-handling","title":"Error Handling","text":"<pre><code>def safe_operation\n  begin\n    risky_work\n    success!\n  rescue SpecificError =&gt; e\n    failure(\"Known issue: #{e.message}\")\n  rescue StandardError =&gt; e\n    failure(\"Unexpected error: #{e.message}\")\n  end\n\n  successful?\nend\n</code></pre>"},{"location":"examples/overview/#logging-and-monitoring","title":"Logging and Monitoring","text":"<pre><code>def tracked_operation\n  Rails.logger.info \"Starting operation for #{@items[:id]}\"\n\n  result = perform_operation\n\n  if successful?\n    Rails.logger.info \"Operation completed successfully\"\n  else\n    Rails.logger.error \"Operation failed: #{errors.join(', ')}\"\n  end\n\n  result\nend\n</code></pre>"},{"location":"examples/overview/#performance-considerations","title":"Performance Considerations","text":"<p>The examples include performance best practices:</p> <ul> <li>Connection pooling for high-throughput scenarios</li> <li>Batch processing for efficiency</li> <li>Memory management for long-running consumers</li> <li>Queue configuration for optimal performance</li> </ul>"},{"location":"examples/overview/#deployment-examples","title":"Deployment Examples","text":"<p>Learn how to deploy BunnyFarm applications:</p> <ul> <li>Docker containers with proper configuration</li> <li>Kubernetes deployment manifests</li> <li>Systemd services for traditional servers</li> <li>Cloud deployment patterns</li> </ul>"},{"location":"examples/overview/#next-steps","title":"Next Steps","text":"<p>Choose an example that matches your use case:</p> <ul> <li>New to BunnyFarm? Start with Simple Producer/Consumer</li> <li>Building workflows? Check out Order Processing</li> <li>Need scheduling? See Task Scheduler</li> <li>Going to production? Review Real World Examples</li> </ul>"},{"location":"examples/real-world/","title":"Real World Examples","text":"<p>Production-ready patterns and implementations.</p>"},{"location":"examples/real-world/#e-commerce-platform","title":"E-commerce Platform","text":"<ul> <li>Order processing</li> <li>Inventory management</li> <li>Customer notifications</li> </ul>"},{"location":"examples/simple-producer-consumer/","title":"Simple Producer/Consumer","text":"<p>Basic example showing message publishing and consumption.</p>"},{"location":"examples/simple-producer-consumer/#producer","title":"Producer","text":"<pre><code>message = GreetingMessage.new\nmessage[:name] = 'World'\nmessage.publish('greet')\n</code></pre>"},{"location":"examples/simple-producer-consumer/#consumer","title":"Consumer","text":"<pre><code>BunnyFarm.manage\n</code></pre>"},{"location":"examples/task-scheduler/","title":"Task Scheduler Example","text":"<p>Scheduled task execution with retry logic.</p> <pre><code>class ScheduledTask &lt; BunnyFarm::Message\n  actions :schedule, :execute\nend\n</code></pre>"},{"location":"getting-started/basic-concepts/","title":"Basic Concepts","text":"<p>Understanding BunnyFarm's core concepts will help you design effective message-driven applications. This guide covers the fundamental principles behind BunnyFarm's architecture.</p>"},{"location":"getting-started/basic-concepts/#message-centric-architecture","title":"Message-Centric Architecture","text":"<p>BunnyFarm is built around the concept of messages as living entities. Unlike traditional job queues where jobs are simple data structures, BunnyFarm messages are full Ruby classes that encapsulate both data and behavior.</p> <p></p> <pre><code>class OrderMessage &lt; BunnyFarm::Message\n  # Data structure\n  fields :order_id, :customer_email, :items\n\n  # Behavior\n  actions :process, :ship, :cancel\n\n  def process\n    validate_order\n    charge_payment\n    update_inventory\n    success!\n  end\nend\n</code></pre>"},{"location":"getting-started/basic-concepts/#core-components","title":"Core Components","text":""},{"location":"getting-started/basic-concepts/#1-message-classes","title":"1. Message Classes","text":"<p>Message classes inherit from <code>BunnyFarm::Message</code> and define:</p> <ul> <li>Fields: The data structure using the <code>fields</code> DSL</li> <li>Actions: Available operations using the <code>actions</code> DSL  </li> <li>Methods: Business logic for each action</li> </ul>"},{"location":"getting-started/basic-concepts/#2-routing-keys","title":"2. Routing Keys","text":"<p>BunnyFarm uses a predictable routing pattern:</p> <pre><code>MessageClassName.action\n</code></pre> <p>Examples: - <code>OrderMessage.process</code> - <code>EmailMessage.send</code> - <code>ReportMessage.generate</code></p> <p>This makes routing transparent and debuggable.</p> <p></p>"},{"location":"getting-started/basic-concepts/#3-json-serialization","title":"3. JSON Serialization","text":"<p>All message data is serialized as JSON for: - Human readability - Easy debugging and monitoring - Language interoperability - Other systems can read/write messages - Simplicity - No complex binary protocols</p> <p></p>"},{"location":"getting-started/basic-concepts/#message-lifecycle","title":"Message Lifecycle","text":"<ol> <li>Creation: Message instance is created with data</li> <li>Publishing: Message is serialized to JSON and sent to RabbitMQ</li> <li>Routing: RabbitMQ routes based on the routing key</li> <li>Consumption: Worker receives and deserializes the message</li> <li>Processing: The appropriate action method is called</li> <li>Acknowledgment: Success/failure determines ACK/NACK</li> </ol>"},{"location":"getting-started/basic-concepts/#fields-dsl","title":"Fields DSL","text":"<p>The <code>fields</code> DSL defines the expected data structure:</p> <pre><code>class CustomerMessage &lt; BunnyFarm::Message\n  fields :name, :email, \n         { address: [:street, :city, :state, :zip] },\n         { preferences: [:newsletter, :promotions] }\nend\n</code></pre> <p>This creates: - Simple fields: <code>name</code>, <code>email</code> - Nested objects: <code>address</code> with sub-fields - Arrays: <code>preferences</code> as a list</p>"},{"location":"getting-started/basic-concepts/#actions-dsl","title":"Actions DSL","text":"<p>The <code>actions</code> DSL defines available operations:</p> <pre><code>class OrderMessage &lt; BunnyFarm::Message\n  actions :validate, :process, :ship, :cancel, :refund\n\n  def validate\n    # Validation logic\n  end\n\n  def process\n    # Processing logic  \n  end\n\n  # ... other action methods\nend\n</code></pre> <p>Each action becomes a routable endpoint.</p>"},{"location":"getting-started/basic-concepts/#data-access","title":"Data Access","text":"<p>BunnyFarm provides hash-like access to message data:</p> <pre><code>message = CustomerMessage.new\n\n# Setting data\nmessage[:name] = \"John Doe\"\nmessage[:email] = \"john@example.com\"\nmessage[:address] = {\n  street: \"123 Main St\",\n  city: \"Boston\", \n  state: \"MA\",\n  zip: \"02101\"\n}\n\n# Getting data\nputs message[:name]           # \"John Doe\"\nputs message[:address][:city] # \"Boston\"\n</code></pre>"},{"location":"getting-started/basic-concepts/#state-management","title":"State Management","text":"<p>Messages track their processing state:</p> <pre><code>def process_order\n  validate_payment\n\n  if payment_valid?\n    charge_customer\n    success!  # Mark as successful\n  else\n    failure(\"Invalid payment method\")\n  end\n\n  successful? # Returns true/false for ACK/NACK\nend\n</code></pre> <p>State methods: - <code>success!</code> - Mark operation as successful - <code>failure(message)</code> - Mark operation as failed with reason - <code>successful?</code> - Check if operation succeeded - <code>failed?</code> - Check if operation failed - <code>errors</code> - Array of error messages</p>"},{"location":"getting-started/basic-concepts/#configuration-patterns","title":"Configuration Patterns","text":"<p>BunnyFarm supports multiple configuration approaches:</p>"},{"location":"getting-started/basic-concepts/#environment-variables","title":"Environment Variables","text":"<pre><code>export AMQP_HOST=localhost\nexport AMQP_EXCHANGE=my_exchange\nexport AMQP_QUEUE=my_queue\n</code></pre>"},{"location":"getting-started/basic-concepts/#programmatic-configuration","title":"Programmatic Configuration","text":"<pre><code>BunnyFarm.config do\n  env 'production'\n  app_id 'order_processor'\n  bunny_file 'config/rabbitmq.yml'\nend\n</code></pre>"},{"location":"getting-started/basic-concepts/#yaml-configuration","title":"YAML Configuration","text":"<pre><code>production:\n  host: amqp.example.com\n  exchange_name: orders\n  queue_name: order_processing\n</code></pre>"},{"location":"getting-started/basic-concepts/#error-handling","title":"Error Handling","text":"<p>BunnyFarm provides built-in error handling:</p> <pre><code>def risky_operation\n  begin\n    perform_external_api_call\n    success!\n  rescue ExternalAPIError =&gt; e\n    failure(\"API call failed: #{e.message}\")\n  rescue StandardError =&gt; e\n    failure(\"Unexpected error: #{e.message}\")\n  end\n\n  successful?\nend\n</code></pre> <p>Failed messages can be: - Retried automatically (RabbitMQ feature) - Sent to dead letter queues - Logged for manual inspection</p>"},{"location":"getting-started/basic-concepts/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/basic-concepts/#1-keep-actions-focused","title":"1. Keep Actions Focused","text":"<p>Each action should have a single responsibility:</p> <pre><code># Good\nactions :validate, :process, :ship\n\n# Avoid\nactions :validate_and_process_and_ship\n</code></pre>"},{"location":"getting-started/basic-concepts/#2-use-meaningful-names","title":"2. Use Meaningful Names","text":"<p>Choose descriptive names for clarity:</p> <pre><code># Good\nclass OrderProcessingMessage\n  actions :validate_payment, :update_inventory\n\n# Better than\nclass OrderMessage  \n  actions :do_stuff, :handle\n</code></pre>"},{"location":"getting-started/basic-concepts/#3-handle-errors-gracefully","title":"3. Handle Errors Gracefully","text":"<p>Always use proper error handling:</p> <pre><code>def process\n  validate_data\n  return unless successful?\n\n  perform_work\n  return unless successful?\n\n  finalize\nend\n</code></pre>"},{"location":"getting-started/basic-concepts/#4-design-for-idempotency","title":"4. Design for Idempotency","text":"<p>Make operations safe to retry:</p> <pre><code>def charge_payment\n  return if payment_already_charged?\n\n  # Perform charge\n  success!\nend\n</code></pre>"},{"location":"getting-started/basic-concepts/#next-steps","title":"Next Steps","text":"<p>With these concepts in mind, you're ready to explore:</p> <ul> <li>Message Structure - Deep dive into Fields and Actions DSL</li> <li>Configuration - Advanced configuration options  </li> <li>Examples - Real-world usage patterns</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>BunnyFarm is distributed as a Ruby gem and can be installed using bundler or gem directly.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<p>Before installing BunnyFarm, ensure you have:</p> <ul> <li>Ruby 2.5 or higher - BunnyFarm supports modern Ruby versions</li> <li>RabbitMQ server - Either local installation or cloud service</li> <li>Bundler - For dependency management</li> </ul>"},{"location":"getting-started/installation/#installing-bunnyfarm","title":"Installing BunnyFarm","text":""},{"location":"getting-started/installation/#using-bundler-recommended","title":"Using Bundler (Recommended)","text":"<p>Add this line to your application's Gemfile:</p> <pre><code>gem 'bunny_farm'\n</code></pre> <p>Then execute:</p> <pre><code>bundle install\n</code></pre>"},{"location":"getting-started/installation/#using-gem-directly","title":"Using Gem Directly","text":"<p>Install it yourself as:</p> <pre><code>gem install bunny_farm\n</code></pre>"},{"location":"getting-started/installation/#setting-up-rabbitmq","title":"Setting up RabbitMQ","text":""},{"location":"getting-started/installation/#local-installation","title":"Local Installation","text":""},{"location":"getting-started/installation/#macos-using-homebrew","title":"macOS (using Homebrew)","text":"<pre><code># Install RabbitMQ\nbrew install rabbitmq\n\n# Start RabbitMQ server\nbrew services start rabbitmq\n\n# Enable management plugin (optional but recommended)\nrabbitmq-plugins enable rabbitmq_management\n</code></pre>"},{"location":"getting-started/installation/#ubuntudebian","title":"Ubuntu/Debian","text":"<pre><code># Install RabbitMQ\nsudo apt-get update\nsudo apt-get install rabbitmq-server\n\n# Start RabbitMQ server\nsudo systemctl start rabbitmq-server\nsudo systemctl enable rabbitmq-server\n\n# Enable management plugin\nsudo rabbitmq-plugins enable rabbitmq_management\n</code></pre>"},{"location":"getting-started/installation/#docker","title":"Docker","text":"<pre><code># Run RabbitMQ with management plugin\ndocker run -d \\\n  --name rabbitmq \\\n  -p 5672:5672 \\\n  -p 15672:15672 \\\n  rabbitmq:3-management\n</code></pre>"},{"location":"getting-started/installation/#cloud-services","title":"Cloud Services","text":"<p>BunnyFarm works with cloud RabbitMQ services:</p> <ul> <li>CloudAMQP - Managed RabbitMQ service</li> <li>Amazon MQ - AWS managed message broker</li> <li>Google Cloud Pub/Sub - With AMQP support</li> <li>Azure Service Bus - With AMQP 1.0 support</li> </ul>"},{"location":"getting-started/installation/#verification","title":"Verification","text":"<p>Verify your installation by checking if BunnyFarm loads correctly:</p> <pre><code>require 'bunny_farm'\nputs BunnyFarm::VERSION\n</code></pre> <p>You should see the version number output without any errors.</p>"},{"location":"getting-started/installation/#environment-setup","title":"Environment Setup","text":"<p>Set up your environment variables for development:</p> <pre><code>export AMQP_HOST=localhost\nexport AMQP_VHOST=/\nexport AMQP_PORT=5672\nexport AMQP_USER=guest\nexport AMQP_PASS=guest\nexport AMQP_EXCHANGE=bunny_farm_exchange\nexport AMQP_QUEUE=bunny_farm_queue\nexport AMQP_ROUTING_KEY='#'\nexport AMQP_APP_NAME=my_bunny_farm_app\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>With BunnyFarm installed and RabbitMQ running, you're ready to:</p> <ol> <li>Quick Start Guide - Get your first message processing in 5 minutes</li> <li>Basic Concepts - Understand BunnyFarm's core concepts</li> <li>Configuration - Learn about configuration options</li> </ol>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>This guide will get you up and running with BunnyFarm in just a few minutes. We'll create a simple message class, publish a message, and process it.</p>"},{"location":"getting-started/quick-start/#prerequisites","title":"Prerequisites","text":"<p>Before starting, make sure you have:</p> <ul> <li>BunnyFarm installed</li> <li>RabbitMQ server running locally or accessible remotely</li> <li>Basic familiarity with Ruby</li> </ul>"},{"location":"getting-started/quick-start/#step-1-create-your-first-message-class","title":"Step 1: Create Your First Message Class","text":"<p>Create a file called <code>greeting_message.rb</code>:</p> <pre><code>require 'bunny_farm'\n\nclass GreetingMessage &lt; BunnyFarm::Message\n  # Define the fields this message expects\n  fields :name, :language\n\n  # Define the actions this message can perform\n  actions :send_greeting\n\n  def send_greeting\n    puts \"Hello #{@items[:name]}! (in #{@items[:language]})\"\n\n    # Mark the message as successfully processed\n    success!\n\n    # Return true to ACK the message\n    successful?\n  end\nend\n</code></pre>"},{"location":"getting-started/quick-start/#step-2-configure-bunnyfarm","title":"Step 2: Configure BunnyFarm","text":"<p>Create a simple configuration (or use environment variables):</p> <pre><code># Basic configuration using defaults\nBunnyFarm.config do\n  app_id 'greeting_app'\nend\n</code></pre>"},{"location":"getting-started/quick-start/#step-3-publish-a-message","title":"Step 3: Publish a Message","text":"<p>Create a file called <code>publisher.rb</code>:</p> <pre><code>require_relative 'greeting_message'\n\n# Configure BunnyFarm\nBunnyFarm.config do\n  app_id 'greeting_publisher'\nend\n\n# Create a new message\nmessage = GreetingMessage.new\n\n# Set the message data\nmessage[:name] = 'Alice'\nmessage[:language] = 'English'\n\n# Publish the message with the 'send_greeting' action\nmessage.publish('send_greeting')\n\nif message.successful?\n  puts \"Message published successfully!\"\nelse\n  puts \"Failed to publish message: #{message.errors.join(', ')}\"\nend\n</code></pre>"},{"location":"getting-started/quick-start/#step-4-create-a-consumer","title":"Step 4: Create a Consumer","text":"<p>Create a file called <code>consumer.rb</code>:</p> <pre><code>require_relative 'greeting_message'\n\n# Configure BunnyFarm\nBunnyFarm.config do\n  app_id 'greeting_consumer'\nend\n\nputs \"Starting message consumer...\"\nputs \"Press Ctrl+C to stop\"\n\n# Start processing messages (this will block)\nBunnyFarm.manage\n</code></pre>"},{"location":"getting-started/quick-start/#step-5-run-the-example","title":"Step 5: Run the Example","text":"<ol> <li> <p>Start the consumer (in one terminal):    <pre><code>ruby consumer.rb\n</code></pre></p> </li> <li> <p>Publish a message (in another terminal):    <pre><code>ruby publisher.rb\n</code></pre></p> </li> </ol> <p>You should see output like:</p> <p>Consumer terminal: <pre><code>Starting message consumer...\nPress Ctrl+C to stop\nHello Alice! (in English)\n</code></pre></p> <p>Publisher terminal: <pre><code>Message published successfully!\n</code></pre></p>"},{"location":"getting-started/quick-start/#understanding-what-happened","title":"Understanding What Happened","text":"<ol> <li>Message Class: <code>GreetingMessage</code> defines the structure and behavior</li> <li>Fields DSL: <code>fields :name, :language</code> specifies expected data</li> <li>Actions DSL: <code>actions :send_greeting</code> defines available operations</li> <li>Routing Key: The message was routed using <code>GreetingMessage.send_greeting</code></li> <li>JSON Serialization: Data was automatically serialized/deserialized</li> <li>AMQP Flow: Message traveled through RabbitMQ from publisher to consumer</li> </ol>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you have a basic understanding, explore:</p> <ul> <li>Basic Concepts - Understand BunnyFarm's architecture</li> <li>Message Structure - Learn about the Fields and Actions DSL</li> <li>Configuration Options - Advanced configuration</li> <li>Examples - More comprehensive examples</li> </ul>"},{"location":"getting-started/quick-start/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/quick-start/#connection-refused","title":"Connection Refused","text":"<p>If you see connection errors, ensure RabbitMQ is running: <pre><code># Check RabbitMQ status\nsudo systemctl status rabbitmq-server\n\n# Or for Docker\ndocker ps | grep rabbitmq\n</code></pre></p>"},{"location":"getting-started/quick-start/#permission-denied","title":"Permission Denied","text":"<p>Make sure your AMQP credentials are correct in your environment variables or configuration.</p>"},{"location":"getting-started/quick-start/#messages-not-processing","title":"Messages Not Processing","text":"<p>Verify that your consumer is listening to the correct queue and routing key configuration.</p>"},{"location":"message-structure/actions-dsl/","title":"Actions DSL","text":"<p>The Actions DSL defines the operations that your message can perform. Each action becomes a routable method that can be called when the message is consumed.</p>"},{"location":"message-structure/actions-dsl/#basic-actions","title":"Basic Actions","text":"<pre><code>class OrderMessage &lt; BunnyFarm::Message\n  actions :validate, :process, :ship, :cancel\n\n  def validate\n    # Validation logic\n    success!\n  end\n\n  def process\n    # Processing logic\n    success!\n  end\n\n  def ship\n    # Shipping logic\n    success!\n  end\n\n  def cancel\n    # Cancellation logic\n    success!\n  end\nend\n</code></pre>"},{"location":"message-structure/actions-dsl/#action-method-implementation","title":"Action Method Implementation","text":"<p>Each action must be implemented as a method:</p> <pre><code>class PaymentMessage &lt; BunnyFarm::Message\n  actions :authorize, :capture, :refund\n\n  def authorize\n    result = payment_gateway.authorize(@items[:amount], @items[:card_token])\n\n    if result.success?\n      @items[:authorization_id] = result.authorization_id\n      success!\n    else\n      failure(\"Authorization failed: #{result.error_message}\")\n    end\n\n    successful?\n  end\n\n  def capture\n    return failure(\"No authorization ID\") unless @items[:authorization_id]\n\n    result = payment_gateway.capture(@items[:authorization_id])\n\n    if result.success?\n      @items[:transaction_id] = result.transaction_id\n      success!\n    else\n      failure(\"Capture failed: #{result.error_message}\")\n    end\n\n    successful?\n  end\nend\n</code></pre>"},{"location":"message-structure/actions-dsl/#action-routing","title":"Action Routing","text":"<p>Actions create routing keys automatically:</p> <pre><code># Publishing creates routing keys\nmessage = PaymentMessage.new\nmessage.publish('authorize')  # Routing key: PaymentMessage.authorize\nmessage.publish('capture')    # Routing key: PaymentMessage.capture\nmessage.publish('refund')     # Routing key: PaymentMessage.refund\n</code></pre>"},{"location":"message-structure/actions-dsl/#action-patterns","title":"Action Patterns","text":""},{"location":"message-structure/actions-dsl/#crud-operations","title":"CRUD Operations","text":"<pre><code>class UserMessage &lt; BunnyFarm::Message\n  actions :create, :read, :update, :delete\nend\n</code></pre>"},{"location":"message-structure/actions-dsl/#workflow-actions","title":"Workflow Actions","text":"<pre><code>class OrderWorkflow &lt; BunnyFarm::Message\n  actions :start, :validate, :process_payment, :fulfill, :ship, :complete\nend\n</code></pre>"},{"location":"message-structure/actions-dsl/#state-machine-actions","title":"State Machine Actions","text":"<pre><code>class DocumentMessage &lt; BunnyFarm::Message\n  actions :draft, :review, :approve, :publish, :archive\nend\n</code></pre>"},{"location":"message-structure/actions-dsl/#action-validation","title":"Action Validation","text":"<pre><code>class ValidatedActions &lt; BunnyFarm::Message\n  actions :process\n\n  def process\n    # Validate before processing\n    return unless validate_preconditions\n\n    # Perform work\n    do_processing\n\n    # Validate after processing\n    return unless validate_postconditions\n\n    success!\n  end\n\n  private\n\n  def validate_preconditions\n    failure(\"Missing required data\") unless required_data_present?\n    successful?\n  end\n\n  def validate_postconditions\n    failure(\"Processing incomplete\") unless processing_complete?\n    successful?\n  end\nend\n</code></pre>"},{"location":"message-structure/actions-dsl/#best-practices","title":"Best Practices","text":""},{"location":"message-structure/actions-dsl/#1-use-descriptive-action-names","title":"1. Use Descriptive Action Names","text":"<pre><code># Good: Clear, descriptive names\nactions :validate_order, :process_payment, :ship_order, :send_confirmation\n\n# Avoid: Vague or generic names\nactions :do_stuff, :handle, :process\n</code></pre>"},{"location":"message-structure/actions-dsl/#2-single-responsibility","title":"2. Single Responsibility","text":"<pre><code># Good: Each action has one purpose\nactions :validate_customer, :validate_inventory, :validate_payment\n\n# Avoid: Actions that do too much\nactions :validate_everything\n</code></pre>"},{"location":"message-structure/actions-dsl/#3-logical-flow","title":"3. Logical Flow","text":"<pre><code># Good: Actions follow logical order\nactions :create_draft, :add_content, :review, :approve, :publish\n</code></pre>"},{"location":"message-structure/fields-dsl/","title":"Fields DSL","text":"<p>The Fields DSL is BunnyFarm's declarative syntax for defining the data structure of your messages. It provides a clean, readable way to specify expected fields and their organization.</p> <p></p>"},{"location":"message-structure/fields-dsl/#basic-field-declaration","title":"Basic Field Declaration","text":"<pre><code>class UserMessage &lt; BunnyFarm::Message\n  # Simple fields\n  fields :user_id, :email, :name, :created_at\nend\n</code></pre>"},{"location":"message-structure/fields-dsl/#nested-objects","title":"Nested Objects","text":"<pre><code>class CustomerMessage &lt; BunnyFarm::Message\n  fields :customer_id, :email,\n         { address: [:street, :city, :state, :zip] },\n         { preferences: [:newsletter, :promotions, :sms] }\nend\n</code></pre>"},{"location":"message-structure/fields-dsl/#complex-structures","title":"Complex Structures","text":"<pre><code>class OrderMessage &lt; BunnyFarm::Message\n  fields :order_id, :total, :tax, :shipping,\n         { customer: [:name, :email, :phone] },\n         { billing_address: [:street, :city, :state, :zip, :country] },\n         { shipping_address: [:street, :city, :state, :zip, :country] },\n         { items: [:product_id, :name, :quantity, :unit_price, :total_price] },\n         { payment: [:method, :transaction_id, :status] }\nend\n</code></pre>"},{"location":"message-structure/fields-dsl/#data-access","title":"Data Access","text":"<pre><code>message = OrderMessage.new\n\n# Simple fields\nmessage[:order_id] = 12345\nmessage[:total] = 99.99\n\n# Nested objects\nmessage[:customer] = {\n  name: \"John Doe\",\n  email: \"john@example.com\",\n  phone: \"+1-555-123-4567\"\n}\n\n# Arrays of objects\nmessage[:items] = [\n  {\n    product_id: 1,\n    name: \"Widget\",\n    quantity: 2,\n    unit_price: 29.99,\n    total_price: 59.98\n  },\n  {\n    product_id: 2,\n    name: \"Gadget\",\n    quantity: 1,\n    unit_price: 39.99,\n    total_price: 39.99\n  }\n]\n\n# Access nested data\nputs message[:customer][:name]        # \"John Doe\"\nputs message[:items][0][:product_id]  # 1\nputs message[:billing_address][:city] # Access nested fields\n</code></pre>"},{"location":"message-structure/fields-dsl/#field-validation","title":"Field Validation","text":"<pre><code>class ValidatedMessage &lt; BunnyFarm::Message\n  fields :user_id, :email, :age\n\n  def validate\n    failure(\"User ID required\") unless @items[:user_id]\n    failure(\"Invalid email\") unless valid_email?(@items[:email])\n    failure(\"Age must be positive\") unless @items[:age]&amp;.positive?\n\n    success! if errors.empty?\n  end\n\n  private\n\n  def valid_email?(email)\n    email =~ /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n  end\nend\n</code></pre>"},{"location":"message-structure/fields-dsl/#dynamic-field-access","title":"Dynamic Field Access","text":"<pre><code>message = OrderMessage.new\n\n# Get all field keys\nfield_keys = message.keys\n# =&gt; [:order_id, :total, :customer, :items, ...]\n\n# Check if field exists\nhas_customer = message.keys.include?(:customer)\n\n# Iterate over fields\nmessage.keys.each do |field|\n  value = message[field]\n  puts \"#{field}: #{value}\"\nend\n</code></pre>"},{"location":"message-structure/fields-dsl/#best-practices","title":"Best Practices","text":""},{"location":"message-structure/fields-dsl/#1-logical-grouping","title":"1. Logical Grouping","text":"<pre><code># Good: Related fields grouped together\nfields :order_id, :status, :created_at,\n       { customer: [:id, :name, :email] },\n       { items: [:id, :name, :price] }\n</code></pre>"},{"location":"message-structure/fields-dsl/#2-consistent-naming","title":"2. Consistent Naming","text":"<pre><code># Good: Consistent snake_case\nfields :user_id, :created_at, :email_address\n\n# Avoid: Mixed conventions\nfields :userId, :created_at, :EmailAddress\n</code></pre>"},{"location":"message-structure/fields-dsl/#3-meaningful-structure","title":"3. Meaningful Structure","text":"<pre><code># Good: Clear hierarchy\nfields { address: [:street, :city, :state, :zip] }\n\n# Avoid: Flat structure\nfields :address_street, :address_city, :address_state, :address_zip\n</code></pre>"},{"location":"message-structure/instance-methods/","title":"Instance Methods","text":"<p>BunnyFarm message instances provide a rich set of methods for data access, state management, and message operations.</p>"},{"location":"message-structure/instance-methods/#data-access-methods","title":"Data Access Methods","text":""},{"location":"message-structure/instance-methods/#hash-like-access","title":"Hash-like Access","text":"<pre><code>message = OrderMessage.new\n\n# Get values\norder_id = message[:order_id]\ncustomer_name = message[:customer][:name]\n\n# Set values\nmessage[:order_id] = 12345\nmessage[:customer] = { name: \"John\", email: \"john@example.com\" }\n</code></pre>"},{"location":"message-structure/instance-methods/#field-introspection","title":"Field Introspection","text":"<pre><code># Get all field keys\nkeys = message.keys  # =&gt; [:order_id, :customer, :items]\n\n# Check if field exists\nhas_customer = message.respond_to?(:[]) &amp;&amp; message[:customer]\n\n# Get field count\nfield_count = message.keys.length\n</code></pre>"},{"location":"message-structure/instance-methods/#state-management","title":"State Management","text":""},{"location":"message-structure/instance-methods/#successfailure-tracking","title":"Success/Failure Tracking","text":"<pre><code>def process_order\n  validate_data\n  return unless successful?\n\n  charge_payment\n  return unless successful?\n\n  update_inventory\n  success!  # Mark as successful\nend\n\n# Check state\nif message.successful?\n  puts \"Order processed successfully\"\nelse\n  puts \"Order failed: #{message.errors.join(', ')}\"\nend\n</code></pre>"},{"location":"message-structure/instance-methods/#error-management","title":"Error Management","text":"<pre><code>def validate\n  failure(\"Order ID required\") unless @items[:order_id]\n  failure(\"Invalid email\") unless valid_email?(@items[:email])\n\n  # Check error state\n  if failed?\n    puts \"Validation errors: #{errors.join(', ')}\"\n  else\n    success!\n  end\nend\n</code></pre>"},{"location":"message-structure/instance-methods/#message-operations","title":"Message Operations","text":""},{"location":"message-structure/instance-methods/#publishing","title":"Publishing","text":"<pre><code># Publish message\nmessage.publish('process')  # Routing key: MessageClass.process\n\n# Check if publish succeeded\nif message.successful?\n  puts \"Message published successfully\"\nelse\n  puts \"Publish failed: #{message.errors.join(', ')}\"\nend\n</code></pre>"},{"location":"message-structure/instance-methods/#serialization","title":"Serialization","text":"<pre><code># Convert to JSON\njson_string = message.to_json\nputs json_string\n# =&gt; {\"order_id\":12345,\"customer\":{\"name\":\"John\"}}\n\n# Get raw payload (if received message)\noriginal_json = message.payload\n</code></pre>"},{"location":"message-structure/instance-methods/#utility-methods","title":"Utility Methods","text":""},{"location":"message-structure/instance-methods/#inspection-and-debugging","title":"Inspection and Debugging","text":"<pre><code># Inspect message contents\nputs message.inspect\n\n# Pretty print for debugging\nputs JSON.pretty_generate(message.to_hash)\n</code></pre>"},{"location":"message-structure/instance-methods/#cloning-and-copying","title":"Cloning and Copying","text":"<pre><code># Create copy with same data\nnew_message = message.class.new\nmessage.keys.each { |key| new_message[key] = message[key] }\n\n# Publish copy with different action\nnew_message.publish('different_action')\n</code></pre>"},{"location":"message-structure/overview/","title":"Message Structure Overview","text":"<p>Understanding how BunnyFarm messages are structured is key to using the library effectively. This section covers the anatomy of a BunnyFarm message and how the DSL components work together.</p> <p></p>"},{"location":"message-structure/overview/#message-class-anatomy","title":"Message Class Anatomy","text":"<p>A BunnyFarm message class consists of several key components:</p> <pre><code>class OrderMessage &lt; BunnyFarm::Message\n  # 1. Fields DSL - Define data structure\n  fields :order_id, :total, \n         { customer: [:name, :email] }, \n         { items: [:id, :qty] }\n\n  # 2. Actions DSL - Define available operations  \n  actions :validate, :process_payment, :ship, :cancel\n\n  # 3. Action Methods - Business logic\n  def validate\n    # Validation logic here\n    success!\n    successful?\n  end\n\n  def process_payment\n    # Payment processing logic\n    success!\n    successful?\n  end\n\n  # 4. Helper Methods (private)\n  private\n\n  def validate_customer\n    # Helper logic\n  end\nend\n</code></pre>"},{"location":"message-structure/overview/#dsl-components","title":"DSL Components","text":""},{"location":"message-structure/overview/#fields-dsl","title":"Fields DSL","text":"<p>The <code>fields</code> DSL defines the expected data structure for your messages:</p> <ul> <li>Simple fields: Basic data types like strings, numbers, booleans</li> <li>Nested objects: Complex data structures with sub-fields</li> <li>Arrays: Lists of items or objects</li> </ul>"},{"location":"message-structure/overview/#actions-dsl","title":"Actions DSL","text":"<p>The <code>actions</code> DSL defines the operations your message can perform:</p> <ul> <li>Each action becomes a routable method</li> <li>Actions map to routing keys: <code>MessageClass.action</code></li> <li>Must implement corresponding methods</li> </ul>"},{"location":"message-structure/overview/#instance-structure","title":"Instance Structure","text":"<p>When a message is instantiated, it contains several important instance variables:</p>"},{"location":"message-structure/overview/#items","title":"@items","text":"<p>Validated and structured data extracted from the raw JSON based on your fields definition.</p> <pre><code>message[:customer][:name] # Access via hash-like interface\n</code></pre>"},{"location":"message-structure/overview/#elements","title":"@elements","text":"<p>Raw JSON data as received from the message broker.</p> <pre><code>message.elements # Access raw data\n</code></pre>"},{"location":"message-structure/overview/#payload","title":"@payload","text":"<p>The original JSON string as received from RabbitMQ.</p> <pre><code>message.payload # Original JSON string\n</code></pre>"},{"location":"message-structure/overview/#errors","title":"@errors","text":"<p>Array of error messages accumulated during processing.</p> <pre><code>message.errors # =&gt; [\"Validation failed\", \"Payment declined\"]\n</code></pre>"},{"location":"message-structure/overview/#data-flow","title":"Data Flow","text":"<p>The message goes through several stages:</p> <ol> <li>JSON Input - Raw message data from RabbitMQ</li> <li>Parse &amp; Validate - Extract fields using DSL definition  </li> <li>Route Action - Call method based on routing key</li> <li>Execute Logic - Run business logic in action method</li> <li>ACK/NACK - Acknowledge to RabbitMQ based on success/failure</li> </ol>"},{"location":"message-structure/overview/#access-methods","title":"Access Methods","text":"<p>BunnyFarm provides several ways to access and manipulate message data:</p>"},{"location":"message-structure/overview/#hash-like-access","title":"Hash-like Access","text":"<pre><code>msg[:field]       # Get value\nmsg[:field] = val # Set value\n</code></pre>"},{"location":"message-structure/overview/#json-serialization","title":"JSON Serialization","text":"<pre><code>msg.to_json # Convert to JSON string\n</code></pre>"},{"location":"message-structure/overview/#field-inspection","title":"Field Inspection","text":"<pre><code>msg.keys # Get all available fields\n</code></pre>"},{"location":"message-structure/overview/#state-management","title":"State Management","text":"<p>Messages track their processing state throughout the lifecycle:</p>"},{"location":"message-structure/overview/#success-states","title":"Success States","text":"<pre><code>success!     # Mark as successful\nsuccessful?  # Check if successful\n</code></pre>"},{"location":"message-structure/overview/#failure-states","title":"Failure States","text":"<pre><code>failure(msg) # Mark as failed with reason\nfailed?      # Check if failed\n</code></pre>"},{"location":"message-structure/overview/#publishing","title":"Publishing","text":"<pre><code>msg.publish(action) # Send message with routing key\n</code></pre>"},{"location":"message-structure/overview/#best-practices","title":"Best Practices","text":""},{"location":"message-structure/overview/#1-design-clear-field-structures","title":"1. Design Clear Field Structures","text":"<pre><code># Good: Clear, hierarchical structure\nfields :order_id, :amount,\n       { customer: [:name, :email, :phone] },\n       { billing_address: [:street, :city, :state, :zip] }\n\n# Avoid: Flat, unclear structure  \nfields :order_id, :customer_name, :customer_email, \n       :billing_street, :billing_city # ... too flat\n</code></pre>"},{"location":"message-structure/overview/#2-use-meaningful-action-names","title":"2. Use Meaningful Action Names","text":"<pre><code># Good: Descriptive action names\nactions :validate_order, :process_payment, :ship_order, :send_confirmation\n\n# Avoid: Generic action names\nactions :process, :handle, :do_work\n</code></pre>"},{"location":"message-structure/overview/#3-implement-proper-error-handling","title":"3. Implement Proper Error Handling","text":"<pre><code>def process_payment\n  return failure(\"Missing payment info\") unless payment_present?\n  return failure(\"Invalid amount\") unless valid_amount?\n\n  charge_result = payment_gateway.charge(@items[:amount])\n\n  if charge_result.success?\n    success!\n  else\n    failure(\"Payment failed: #{charge_result.error}\")\n  end\n\n  successful?\nend\n</code></pre>"},{"location":"message-structure/overview/#4-keep-methods-focused","title":"4. Keep Methods Focused","text":"<p>Each action method should have a single, clear responsibility:</p> <pre><code>def validate_order\n  validate_customer_info\n  validate_items\n  validate_shipping_address\n\n  success! if errors.empty?\n  successful?\nend\n\nprivate\n\ndef validate_customer_info\n  failure(\"Customer name required\") if @items[:customer][:name].blank?\n  failure(\"Customer email required\") if @items[:customer][:email].blank?\nend\n</code></pre>"},{"location":"message-structure/overview/#next-steps","title":"Next Steps","text":"<p>Now that you understand message structure, explore:</p> <ul> <li>Fields DSL - Detailed guide to defining data structures</li> <li>Actions DSL - Complete actions DSL reference</li> <li>Instance Methods - All available instance methods</li> <li>Configuration - Message configuration options</li> </ul>"}]}